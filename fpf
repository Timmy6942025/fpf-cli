#!/usr/bin/env bash

set -euo pipefail

SCRIPT_NAME="fpf"
SCRIPT_VERSION="1.6.8"
TMP_ROOT="${TMPDIR:-/tmp}/fpf"
SESSION_TMP_ROOT=""
HELP_FILE=""
KBINDS_FILE=""

ACTION="search"
MANAGER_OVERRIDE=""
declare -a QUERY_PARTS=()

log() {
    printf "%s\n" "$*" >&2
}

die() {
    log "Error: $*"
    exit 1
}

command_exists() {
    command -v "$1" >/dev/null 2>&1
}

ensure_tmp_root() {
    mkdir -p "${TMP_ROOT}"
}

initialize_session_tmp_root() {
    if [[ -n "${SESSION_TMP_ROOT}" ]]; then
        return
    fi

    SESSION_TMP_ROOT="$(mktemp -d "${TMP_ROOT}/session.XXXXXX")"
    HELP_FILE="${SESSION_TMP_ROOT}/help"
    KBINDS_FILE="${SESSION_TMP_ROOT}/keybinds"
}

cleanup_session_tmp_root() {
    if [[ -n "${SESSION_TMP_ROOT}" && -d "${SESSION_TMP_ROOT}" ]]; then
        rm -rf "${SESSION_TMP_ROOT}"
    fi
}

run_as_root() {
    if [[ "${EUID}" -eq 0 ]]; then
        "$@"
        return
    fi

    if command_exists sudo; then
        sudo "$@"
        return
    fi

    die "Root privileges are required for: $*"
}

manager_list() {
    printf "%s\n" "apt dnf pacman zypper emerge brew winget choco scoop snap flatpak npm bun"
}

manager_supported() {
    local manager="$1"
    case "${manager}" in
        apt|dnf|pacman|zypper|emerge|brew|winget|choco|scoop|snap|flatpak|npm|bun)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

manager_command_ready() {
    local manager="$1"
    case "${manager}" in
        apt)
            command_exists apt-cache && command_exists apt-get && command_exists dpkg-query
            ;;
        dnf)
            command_exists dnf
            ;;
        pacman)
            command_exists pacman
            ;;
        zypper)
            command_exists zypper
            ;;
        emerge)
            command_exists emerge
            ;;
        brew)
            command_exists brew
            ;;
        winget)
            command_exists winget
            ;;
        choco)
            command_exists choco
            ;;
        scoop)
            command_exists scoop
            ;;
        snap)
            command_exists snap
            ;;
        flatpak)
            command_exists flatpak
            ;;
        npm)
            command_exists npm
            ;;
        bun)
            command_exists bun
            ;;
        *)
            return 1
            ;;
    esac
}

manager_can_install_fzf() {
    local manager="$1"
    case "${manager}" in
        apt|dnf|pacman|zypper|emerge|brew|winget|choco|scoop|snap)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

install_fzf_with_manager() {
    local manager="$1"

    case "${manager}" in
        apt)
            run_as_root apt-get install -y fzf
            ;;
        dnf)
            run_as_root dnf install -y fzf
            ;;
        pacman)
            run_as_root pacman -S --needed fzf
            ;;
        zypper)
            run_as_root zypper --non-interactive install --auto-agree-with-licenses fzf
            ;;
        emerge)
            run_as_root emerge --ask=n app-shells/fzf
            ;;
        brew)
            brew install fzf
            ;;
        winget)
            winget install --id junegunn.fzf --exact --source winget --accept-package-agreements --accept-source-agreements --disable-interactivity ||
                winget install --id fzf --exact --source winget --accept-package-agreements --accept-source-agreements --disable-interactivity
            ;;
        choco)
            choco install fzf -y
            ;;
        scoop)
            scoop install fzf
            ;;
        snap)
            run_as_root snap install fzf
            ;;
        *)
            return 1
            ;;
    esac
}

build_fzf_bootstrap_candidates() {
    local seen=""
    local manager

    for manager in "$@"; do
        [[ -n "${manager}" ]] || continue
        manager_can_install_fzf "${manager}" || continue
        manager_command_ready "${manager}" || continue
        case " ${seen} " in
            *" ${manager} "*)
                continue
                ;;
        esac
        printf "%s\n" "${manager}"
        seen+=" ${manager}"
    done

    if [[ -n "${seen}" ]]; then
        return
    fi

    for manager in apt dnf pacman zypper emerge brew winget choco scoop snap; do
        manager_command_ready "${manager}" || continue
        case " ${seen} " in
            *" ${manager} "*)
                continue
                ;;
        esac
        printf "%s\n" "${manager}"
        seen+=" ${manager}"
    done
}

ensure_fzf() {
    local candidates=()
    local manager

    if command_exists fzf; then
        return
    fi

    while IFS= read -r manager; do
        [[ -n "${manager}" ]] || continue
        candidates+=("${manager}")
    done < <(build_fzf_bootstrap_candidates "$@")

    if [[ "${#candidates[@]}" -eq 0 ]]; then
        die "fzf is required and no compatible manager is available to auto-install it"
    fi

    local candidate_labels
    candidate_labels="$(join_manager_labels "${candidates[@]-}")"

    log "fzf is missing. Auto-installing with: ${candidate_labels}"

    for manager in "${candidates[@]-}"; do
        log "Attempting fzf install with $(manager_label "${manager}")"
        if install_fzf_with_manager "${manager}"; then
            if command_exists fzf; then
                return
            fi
        fi
    done

    die "Failed to auto-install fzf. Install fzf manually and rerun."
}

normalize_manager() {
    printf "%s" "$1" | tr '[:upper:]' '[:lower:]'
}

os_release_field() {
    local file_path="$1"
    local field_name="$2"

    awk -v key="${field_name}" '
        index($0, key "=") == 1 {
            value = substr($0, index($0, "=") + 1)
            gsub(/^[[:space:]]+|[[:space:]]+$/, "", value)
            if (value ~ /^".*"$/ || value ~ /^\047.*\047$/) {
                value = substr(value, 2, length(value) - 2)
            }
            print tolower(value)
            exit
        }
    ' "${file_path}"
}

manager_label() {
    local manager="$1"
    case "${manager}" in
        apt) printf "APT" ;;
        dnf) printf "DNF" ;;
        pacman) printf "Pacman" ;;
        zypper) printf "Zypper" ;;
        emerge) printf "Portage (emerge)" ;;
        brew) printf "Homebrew" ;;
        winget) printf "WinGet" ;;
        choco) printf "Chocolatey" ;;
        scoop) printf "Scoop" ;;
        snap) printf "Snap" ;;
        flatpak) printf "Flatpak" ;;
        npm) printf "npm" ;;
        bun) printf "bun" ;;
        *) printf "%s" "${manager}" ;;
    esac
}

detect_default_manager() {
    local os
    os="$(uname -s)"

    if [[ "${os}" == "Darwin" ]]; then
        if command_exists brew; then
            printf "brew"
            return
        fi
    fi

    if [[ "${os}" == MINGW* || "${os}" == MSYS* || "${os}" == CYGWIN* || "${os}" == "Windows_NT" ]]; then
        if command_exists winget; then printf "winget"; return; fi
        if command_exists choco; then printf "choco"; return; fi
        if command_exists scoop; then printf "scoop"; return; fi
        if command_exists npm; then printf "npm"; return; fi
        if command_exists bun; then printf "bun"; return; fi
    fi

    if [[ "${os}" == "Linux" ]]; then
        local distro_id=""
        local distro_like=""
        local os_release_file="${FPF_OS_RELEASE_FILE:-}"

        if [[ -n "${os_release_file}" && ! -r "${os_release_file}" ]]; then
            die "FPF_OS_RELEASE_FILE is set but not readable: ${os_release_file}"
        fi

        if [[ -z "${os_release_file}" && -r /etc/os-release ]]; then
            os_release_file="/etc/os-release"
        elif [[ -z "${os_release_file}" && -r /usr/lib/os-release ]]; then
            os_release_file="/usr/lib/os-release"
        fi

        if [[ -n "${os_release_file}" ]]; then
            distro_id="$(os_release_field "${os_release_file}" "ID")"
            distro_like="$(os_release_field "${os_release_file}" "ID_LIKE")"
        fi

        case "${distro_id} ${distro_like}" in
            *arch*|*manjaro*)
                if command_exists pacman; then printf "pacman"; return; fi
                ;;
            *ubuntu*|*debian*|*linuxmint*|*pop*|*elementary*)
                if command_exists apt-get; then printf "apt"; return; fi
                ;;
            *fedora*|*rhel*|*centos*|*rocky*|*alma*)
                if command_exists dnf; then printf "dnf"; return; fi
                ;;
            *opensuse*|*suse*|*sles*)
                if command_exists zypper; then printf "zypper"; return; fi
                ;;
            *gentoo*)
                if command_exists emerge; then printf "emerge"; return; fi
                ;;
        esac

        if command_exists apt-get; then printf "apt"; return; fi
        if command_exists dnf; then printf "dnf"; return; fi
        if command_exists pacman; then printf "pacman"; return; fi
        if command_exists zypper; then printf "zypper"; return; fi
        if command_exists emerge; then printf "emerge"; return; fi
        if command_exists snap; then printf "snap"; return; fi
        if command_exists flatpak; then printf "flatpak"; return; fi
        if command_exists npm; then printf "npm"; return; fi
        if command_exists bun; then printf "bun"; return; fi
    fi

    if command_exists brew; then printf "brew"; return; fi
    if command_exists winget; then printf "winget"; return; fi
    if command_exists choco; then printf "choco"; return; fi
    if command_exists scoop; then printf "scoop"; return; fi
    if command_exists npm; then printf "npm"; return; fi
    if command_exists bun; then printf "bun"; return; fi

    die "Unable to auto-detect a supported package manager. Use --manager."
}

detect_default_managers() {
    local emitted=""
    local primary_manager=""
    local manager

    add_detected_manager() {
        local manager_name="$1"
        [[ -n "${manager_name}" ]] || return
        case " ${emitted} " in
            *" ${manager_name} "*)
                return
                ;;
        esac
        if manager_command_ready "${manager_name}"; then
            printf "%s\n" "${manager_name}"
            emitted+=" ${manager_name}"
        fi
    }

    primary_manager="$(detect_default_manager)"
    add_detected_manager "${primary_manager}"

    for manager in apt dnf pacman zypper emerge brew winget choco scoop snap flatpak npm bun; do
        add_detected_manager "${manager}"
    done

    if [[ -n "${emitted}" ]]; then
        return
    fi

    die "Unable to auto-detect supported package managers. Use --manager."
}

join_manager_labels() {
    local out=""
    local mgr

    for mgr in "$@"; do
        [[ -n "${mgr}" ]] || continue
        if [[ -n "${out}" ]]; then
            out+=", "
        fi
        out+="$(manager_label "${mgr}")"
    done

    printf "%s" "${out}"
}

join_manager_labels_with_ids() {
    local out=""
    local mgr

    for mgr in "$@"; do
        [[ -n "${mgr}" ]] || continue
        if [[ -n "${out}" ]]; then
            out+=", "
        fi
        out+="$(manager_label "${mgr}") (${mgr})"
    done

    printf "%s" "${out}"
}

build_help_file() {
    local default_managers="$1"

    cat >"${HELP_FILE}" <<EOF
${SCRIPT_NAME} - fuzzy package finder

Syntax:
  ${SCRIPT_NAME} [manager option] [action option] [query]
  ${SCRIPT_NAME} -m|--manager <name> [action option] [query]

Default behavior:
  Fuzzy-search available packages and install selected items.

Detected default manager(s):
  ${default_managers}

Action options:
  -l, --list-installed   Fuzzy-search installed packages and show details
  -R, --remove           Fuzzy-search installed packages and remove selected
  -U, --update           Run manager update/upgrade flow
  -v, --version          Print version and exit
  -h, --help             Show this help

Manager options (one or two-letter style):
  -ap, --apt             Use APT
  -dn, --dnf             Use DNF
  -pm, --pacman          Use Pacman
  -zy, --zypper          Use Zypper
  -em, --emerge          Use Portage (emerge)
  -br, --brew            Use Homebrew
  -wg, --winget          Use WinGet
  -ch, --choco           Use Chocolatey
  -sc, --scoop           Use Scoop
  -sn, --snap            Use Snap
  -fp, --flatpak         Use Flatpak
  -np, --npm             Use npm (global packages)
  -bn, --bun             Use bun (global packages)
  -ad, --auto            Force auto-detection mode

Examples:
  ${SCRIPT_NAME} docker
  ${SCRIPT_NAME} -dn nginx
  ${SCRIPT_NAME} -ap -l openssl
  ${SCRIPT_NAME} -br -R wget
  ${SCRIPT_NAME} -sn firefox
  ${SCRIPT_NAME} -fp org.gimp.GIMP
  ${SCRIPT_NAME} -wg Microsoft.VisualStudioCode
  ${SCRIPT_NAME} -np eslint
  ${SCRIPT_NAME} -ch git
  ${SCRIPT_NAME} -m apt ripgrep

Supported managers:
  $(manager_list)
EOF
}

build_keybind_file() {
    cat >"${KBINDS_FILE}" <<'EOF'
Keybinds:

  ctrl-h  Show help in preview pane
  ctrl-k  Show keybinds in preview pane
  ctrl-/  Toggle preview pane
  ctrl-n  Move to next selected package
  ctrl-b  Move to previous selected package
EOF
}

print_help() {
    cat "${HELP_FILE}"
}

print_version() {
    printf "%s %s\n" "${SCRIPT_NAME}" "${SCRIPT_VERSION}"
}

parse_args() {
    while (($#)); do
        case "$1" in
            -h|--help)
                ACTION="help"
                ;;
            -v|--version)
                ACTION="version"
                ;;
            -l|--list-installed)
                ACTION="list"
                ;;
            -R|--remove)
                ACTION="remove"
                ;;
            -U|--update)
                ACTION="update"
                ;;
            --feed-search)
                ACTION="feed-search"
                ;;
            -ap|--apt)
                MANAGER_OVERRIDE="apt"
                ;;
            -dn|--dnf)
                MANAGER_OVERRIDE="dnf"
                ;;
            -pm|--pacman)
                MANAGER_OVERRIDE="pacman"
                ;;
            -zy|--zypper)
                MANAGER_OVERRIDE="zypper"
                ;;
            -em|--emerge)
                MANAGER_OVERRIDE="emerge"
                ;;
            -br|--brew)
                MANAGER_OVERRIDE="brew"
                ;;
            -wg|--winget)
                MANAGER_OVERRIDE="winget"
                ;;
            -ch|--choco)
                MANAGER_OVERRIDE="choco"
                ;;
            -sc|--scoop)
                MANAGER_OVERRIDE="scoop"
                ;;
            -sn|--snap)
                MANAGER_OVERRIDE="snap"
                ;;
            -fp|--flatpak)
                MANAGER_OVERRIDE="flatpak"
                ;;
            -np|--npm)
                MANAGER_OVERRIDE="npm"
                ;;
            -bn|--bun)
                MANAGER_OVERRIDE="bun"
                ;;
            -ad|--auto)
                MANAGER_OVERRIDE=""
                ;;
            -m|--manager)
                shift
                [[ $# -gt 0 ]] || die "Missing value for --manager"
                MANAGER_OVERRIDE="$(normalize_manager "$1")"
                ;;
            --)
                shift
                while (($#)); do
                    QUERY_PARTS+=("$1")
                    shift
                done
                break
                ;;
            -*)
                die "Invalid option: $1"
                ;;
            *)
                QUERY_PARTS+=("$1")
                ;;
        esac
        shift
    done
}

join_query() {
    local query=""
    local part

    if (( ${#QUERY_PARTS[@]} == 0 )); then
        printf ""
        return
    fi

    for part in "${QUERY_PARTS[@]-}"; do
        if [[ -z "${query}" ]]; then
            query="${part}"
        else
            query+=" ${part}"
        fi
    done
    printf "%s" "${query}"
}

query_is_single_token() {
    local query="$1"
    [[ -n "${query}" && "${query}" != *[[:space:]]* ]]
}

exact_match_entry() {
    local manager="$1"
    local query="$2"

    if ! query_is_single_token "${query}"; then
        return 0
    fi

    case "${manager}" in
        brew)
            if brew info --formula "${query}" >/dev/null 2>&1 || brew info --cask "${query}" >/dev/null 2>&1; then
                printf "%s\t-\n" "${query}"
            fi
            ;;
        npm|bun)
            if command_exists npm && npm view "${query}" name >/dev/null 2>&1; then
                printf "%s\t-\n" "${query}"
            fi
            ;;
    esac
}

manager_search_entries() {
    local manager="$1"
    local query="$2"
    local effective_query="${query}"
    local npm_search_limit=500
    local line_limit=0

    if [[ -z "${query}" ]]; then
        npm_search_limit="${FPF_NO_QUERY_NPM_LIMIT:-120}"
        line_limit="${FPF_NO_QUERY_RESULT_LIMIT:-200}"
    fi

    if ! [[ "${npm_search_limit}" =~ ^[0-9]+$ ]] || [[ "${npm_search_limit}" -eq 0 ]]; then
        npm_search_limit=500
    fi

    if ! [[ "${line_limit}" =~ ^[0-9]+$ ]]; then
        line_limit=0
    fi

    if [[ -z "${effective_query}" ]]; then
        case "${manager}" in
            apt|dnf|pacman|zypper|emerge|choco|scoop|snap|flatpak)
                effective_query="a"
                ;;
            brew|npm|bun)
                effective_query="aa"
                ;;
            winget)
                effective_query="aa"
                ;;
        esac
    fi

    case "${manager}" in
        apt)
            apt-cache search -- "${effective_query}" 2>/dev/null |
                awk -F' - ' '{ name=$1; desc=$2; gsub(/^[[:space:]]+|[[:space:]]+$/, "", name); if (desc == "") desc="-"; print name "\t" desc }'
            ;;
        dnf)
            local pattern="*"
            if [[ -n "${effective_query}" ]]; then
                pattern="*${effective_query}*"
            fi
            dnf -q list available "${pattern}" 2>/dev/null |
                awk 'NR > 1 && $1 !~ /^(Available|Last|Installed)/ { name=$1; sub(/\.[^.]+$/, "", name); print name "\t" $2 }'
            ;;
        pacman)
            pacman -Ss -- "${effective_query}" 2>/dev/null |
                awk '
                    NR % 2 == 1 {
                        split($1, parts, "/")
                        pkg = parts[2]
                        next
                    }
                    NR % 2 == 0 {
                        line = $0
                        sub(/^[[:space:]]+/, "", line)
                        if (pkg != "") print pkg "\t" line
                    }
                '
            ;;
        zypper)
            zypper --non-interactive --quiet search --details --type package "${effective_query}" 2>/dev/null |
                awk -F'|' '
                    /^[[:space:]]*[ivp ][[:space:]]*\|/ {
                        name=$3
                        ver=$5
                        repo=$7
                        gsub(/^[[:space:]]+|[[:space:]]+$/, "", name)
                        gsub(/^[[:space:]]+|[[:space:]]+$/, "", ver)
                        gsub(/^[[:space:]]+|[[:space:]]+$/, "", repo)
                        if (name != "") print name "\tversion " ver " from " repo
                    }
                '
            ;;
        emerge)
            emerge --searchdesc --color=n "${effective_query}" 2>/dev/null |
                awk '
                    /^\*  / {
                        atom=$2
                        desc="-"
                        next
                    }
                    /^[[:space:]]+Description:/ {
                        line=$0
                        sub(/^[[:space:]]+Description:[[:space:]]*/, "", line)
                        desc=line
                        if (atom != "") print atom "\t" desc
                        atom=""
                    }
                '
            ;;
        brew)
            {
                brew search "${effective_query}" 2>/dev/null |
                    awk 'NF > 0 && $1 != "==>" { print $1 "\t-" }'
                exact_match_entry "${manager}" "${query}"
            }
            ;;
        winget)
            winget search "${effective_query}" --source winget --accept-source-agreements --disable-interactivity 2>/dev/null |
                awk '
                    /^[[:space:]]*$/ { next }
                    /^Name[[:space:]]+Id[[:space:]]+/ { next }
                    /^[-[:space:]]+$/ { next }
                    {
                        line = $0
                        sub(/^[[:space:]]+/, "", line)
                        pkg = ""
                        n = split(line, cols, /[[:space:]][[:space:]]+/)
                        if (n >= 2) {
                            pkg = cols[2]
                        }
                        if (pkg != "") {
                            print pkg "\t-"
                        }
                    }
                '
            ;;
        choco)
            choco search "${effective_query}" --limit-output 2>/dev/null |
                awk -F'|' 'NF >= 1 && $1 != "" { ver=$2; if (ver == "") ver="-"; print $1 "\tversion " ver }'
            ;;
        scoop)
            scoop search "${effective_query}" 2>/dev/null |
                awk '
                    /^[[:space:]]*$/ { next }
                    /^[-[:space:]]+$/ { next }
                    /^Name[[:space:]]+/ { next }
                    {
                        name = $1
                        $1 = ""
                        sub(/^[[:space:]]+/, "", $0)
                        if ($0 == "") $0 = "-"
                        print name "\t" $0
                    }
                '
            ;;
        snap)
            snap find "${effective_query}" 2>/dev/null |
                awk '
                    NR == 1 { next }
                    NF > 0 {
                        name=$1
                        $1=""
                        sub(/^[[:space:]]+/, "", $0)
                        if ($0 == "") $0 = "-"
                        print name "\t" $0
                    }
                '
            ;;
        flatpak)
            if [[ -z "${effective_query}" ]]; then
                {
                    flatpak remote-ls --app --columns=application,description flathub 2>/dev/null ||
                    flatpak remote-ls --app --columns=application,description 2>/dev/null
                } |
                    awk 'NR > 1 { name=$1; $1=""; sub(/^[[:space:]]+/, "", $0); if ($0 == "") $0="-"; print name "\t" $0 }'
            else
                {
                    flatpak search --columns=application,description "${effective_query}" 2>/dev/null ||
                    flatpak search "${effective_query}" 2>/dev/null
                } |
                    awk 'NR > 1 { name=$1; $1=""; sub(/^[[:space:]]+/, "", $0); if ($0 == "") $0="-"; print name "\t" $0 }'
            fi
            ;;
        npm)
            {
                npm search "${effective_query}" --searchlimit="${npm_search_limit}" --parseable 2>/dev/null |
                    awk -F'\t' 'NF >= 2 { print $1 "\t" $2 }'
                exact_match_entry "${manager}" "${query}"
            }
            ;;
        bun)
            {
                if bun search "${effective_query}" >/dev/null 2>&1; then
                    bun search "${effective_query}" 2>/dev/null |
                        awk 'NR > 1 && NF > 0 { name=$1; $1=""; sub(/^[[:space:]]+/, "", $0); if ($0 == "") $0="-"; print name "\t" $0 }'
                elif command_exists npm; then
                    npm search "${effective_query}" --searchlimit="${npm_search_limit}" --parseable 2>/dev/null |
                        awk -F'\t' 'NF >= 2 { print $1 "\t" $2 }'
                fi
                exact_match_entry "${manager}" "${query}"
            } || true
            ;;
    esac | awk -F'\t' 'NF >= 1 { if ($2 == "") $2 = "-"; print $1 "\t" $2 }' | sort -u | {
        if [[ "${line_limit}" -gt 0 ]]; then
            awk -v limit="${line_limit}" 'NR <= limit'
        else
            cat
        fi
    } || true
}

manager_installed_entries() {
    local manager="$1"

    case "${manager}" in
        apt)
            dpkg-query -W -f='${binary:Package}\t${Version}\n' 2>/dev/null
            ;;
        dnf)
            dnf -q list installed 2>/dev/null |
                awk 'NR > 1 && $1 !~ /^(Installed|Last)/ { name=$1; sub(/\.[^.]+$/, "", name); print name "\t" $2 }'
            ;;
        pacman)
            pacman -Q 2>/dev/null |
                awk '{ print $1 "\t" $2 }'
            ;;
        zypper)
            zypper --non-interactive --quiet search --installed-only --details --type package 2>/dev/null |
                awk -F'|' '
                    /^[[:space:]]*i[[:space:]]*\|/ {
                        name=$3
                        ver=$5
                        gsub(/^[[:space:]]+|[[:space:]]+$/, "", name)
                        gsub(/^[[:space:]]+|[[:space:]]+$/, "", ver)
                        if (name != "") print name "\t" ver
                    }
                '
            ;;
        emerge)
            if command_exists qlist; then
                qlist -ICv 2>/dev/null |
                    awk '{ print $1 "\tinstalled" }'
            else
                local pkg_dir
                for pkg_dir in /var/db/pkg/*/*; do
                    [[ -d "${pkg_dir}" ]] || continue
                    printf "%s\tinstalled\n" "$(basename "${pkg_dir}")"
                done
            fi
            ;;
        brew)
            brew list --versions 2>/dev/null |
                awk '{ name=$1; $1=""; sub(/^[[:space:]]+/, "", $0); if ($0 == "") $0="installed"; print name "\t" $0 }'
            ;;
        winget)
            winget list --source winget --accept-source-agreements --disable-interactivity 2>/dev/null |
                awk '
                    /^[[:space:]]*$/ { next }
                    /^Name[[:space:]]+Id[[:space:]]+/ { next }
                    /^[-[:space:]]+$/ { next }
                    {
                        line = $0
                        sub(/^[[:space:]]+/, "", line)

                        pkg = ""
                        ver = "installed"

                        n = split(line, cols, /[[:space:]][[:space:]]+/)
                        if (n >= 2) {
                            pkg = cols[2]
                        }
                        if (n >= 3 && cols[3] != "") {
                            ver = cols[3]
                        }

                        if (pkg != "") {
                            print pkg "\t" ver
                        }
                    }
                '
            ;;
        choco)
            choco list --local-only --limit-output 2>/dev/null |
                awk -F'|' 'NF >= 1 && $1 != "" { ver=$2; if (ver == "") ver="installed"; print $1 "\t" ver }'
            ;;
        scoop)
            scoop list 2>/dev/null |
                awk '
                    /^[[:space:]]*$/ { next }
                    /^[-[:space:]]+$/ { next }
                    /^Name[[:space:]]+/ { next }
                    {
                        ver = $2
                        if (ver == "") ver = "installed"
                        print $1 "\t" ver
                    }
                '
            ;;
        snap)
            snap list 2>/dev/null |
                awk 'NR > 1 { print $1 "\t" $2 }'
            ;;
        flatpak)
            flatpak list --app --columns=application,version 2>/dev/null |
                awk 'NR > 1 { print $1 "\t" $2 }'
            ;;
        npm)
            npm ls -g --depth=0 --parseable 2>/dev/null |
                awk -F'/' 'NR > 1 { print $NF "\tglobal" }'
            ;;
        bun)
            {
                if bun pm ls --global >/dev/null 2>&1; then
                    bun pm ls --global 2>/dev/null |
                        awk 'NR > 1 && NF > 0 { print $1 "\tglobal" }'
                elif command_exists npm; then
                    npm ls -g --depth=0 --parseable 2>/dev/null |
                        awk -F'/' 'NR > 1 { print $NF "\tglobal" }'
                fi
            } || true
            ;;
    esac | sort -u || true
}

manager_installed_names() {
    local manager="$1"
    manager_installed_entries "${manager}" | awk -F'\t' 'NF > 0 { print $1 }'
}

mark_installed_packages() {
    local manager="$1"
    local source_file="$2"
    local output_file="$3"
    local installed_file

    installed_file="$(mktemp "${SESSION_TMP_ROOT}/installed.XXXXXX")"
    manager_installed_names "${manager}" >"${installed_file}" 2>/dev/null || true

    awk -F'\t' '
        FILENAME == ARGV[1] {
            if ($1 != "") {
                installed[$1] = 1
            }
            next
        }
        {
            mark = (installed[$1] ? "\033[32m*\033[0m " : "  ")
            desc = $2
            if (desc == "") desc = "-"
            print $1 "\t" mark desc
        }
    ' "${installed_file}" "${source_file}" >"${output_file}"

    rm -f "${installed_file}"
}

collect_search_display_rows() {
    local query="$1"
    local output_file="$2"
    shift 2
    local managers=("$@")

    : >"${output_file}"

    local part_files=()
    local gather_pids=()
    local manager
    local part_file
    local gather_pid

    for manager in "${managers[@]-}"; do
        part_file="$(mktemp "${SESSION_TMP_ROOT}/part.XXXXXX")"
        part_files+=("${part_file}")

        (
            local_source_file="$(mktemp "${SESSION_TMP_ROOT}/source.XXXXXX")"
            local_marked_file="$(mktemp "${SESSION_TMP_ROOT}/marked.XXXXXX")"
            manager_search_entries "${manager}" "${query}" >"${local_source_file}" || true
            if [[ -s "${local_source_file}" ]]; then
                mark_installed_packages "${manager}" "${local_source_file}" "${local_marked_file}"
                awk -F'\t' -v mgr="${manager}" '
                    NF >= 1 {
                        desc = $2
                        if (desc == "") desc = "-"
                        print mgr "\t" $1 "\t" desc
                    }
                ' "${local_marked_file}" >"${part_file}"
            fi
            rm -f "${local_source_file}" "${local_marked_file}"
        ) &
        gather_pids+=("$!")
    done

    for gather_pid in "${gather_pids[@]-}"; do
        wait "${gather_pid}" || true
    done

    for part_file in "${part_files[@]-}"; do
        if [[ -s "${part_file}" ]]; then
            cat "${part_file}" >>"${output_file}"
        fi
        rm -f "${part_file}"
    done

    if [[ -s "${output_file}" ]]; then
        sort -u "${output_file}" -o "${output_file}"
    fi
}

build_dynamic_reload_command() {
    local manager_override="$1"
    local script_path="${BASH_SOURCE[0]}"

    if [[ "${script_path}" != /* ]]; then
        script_path="$(pwd)/${script_path}"
    fi

    if [[ -n "${manager_override}" ]]; then
        printf "%q --feed-search --manager %q -- {q} 2>/dev/null || true" "${script_path}" "${manager_override}"
    else
        printf "%q --feed-search -- {q} 2>/dev/null || true" "${script_path}"
    fi
}

manager_install() {
    local manager="$1"
    shift

    case "${manager}" in
        apt)
            run_as_root apt-get install -y "$@"
            ;;
        dnf)
            run_as_root dnf install -y "$@"
            ;;
        pacman)
            run_as_root pacman -S --needed "$@"
            ;;
        zypper)
            run_as_root zypper --non-interactive install --auto-agree-with-licenses "$@"
            ;;
        emerge)
            run_as_root emerge --ask=n --verbose "$@"
            ;;
        brew)
            brew install "$@"
            ;;
        winget)
            local pkg
            for pkg in "$@"; do
                winget install --id "${pkg}" --exact --source winget --accept-package-agreements --accept-source-agreements --disable-interactivity
            done
            ;;
        choco)
            choco install "$@" -y
            ;;
        scoop)
            scoop install "$@"
            ;;
        snap)
            local pkg
            for pkg in "$@"; do
                run_as_root snap install "${pkg}" 2>/dev/null || run_as_root snap install --classic "${pkg}"
            done
            ;;
        flatpak)
            local pkg
            for pkg in "$@"; do
                flatpak install -y --user flathub "${pkg}" 2>/dev/null ||
                    flatpak install -y --user "${pkg}" 2>/dev/null ||
                    run_as_root flatpak install -y flathub "${pkg}" 2>/dev/null ||
                    run_as_root flatpak install -y "${pkg}"
            done
            ;;
        npm)
            npm install -g "$@"
            ;;
        bun)
            bun add -g "$@"
            ;;
    esac
}

manager_remove() {
    local manager="$1"
    shift

    case "${manager}" in
        apt)
            run_as_root apt-get remove -y "$@"
            ;;
        dnf)
            run_as_root dnf remove -y "$@"
            ;;
        pacman)
            run_as_root pacman -Rsn "$@"
            ;;
        zypper)
            run_as_root zypper --non-interactive remove "$@"
            ;;
        emerge)
            run_as_root emerge --ask=n --deselect "$@"
            run_as_root emerge --ask=n --depclean "$@"
            ;;
        brew)
            brew uninstall "$@"
            ;;
        winget)
            local pkg
            for pkg in "$@"; do
                winget uninstall --id "${pkg}" --exact --source winget --disable-interactivity
            done
            ;;
        choco)
            choco uninstall "$@" -y
            ;;
        scoop)
            scoop uninstall "$@"
            ;;
        snap)
            run_as_root snap remove "$@"
            ;;
        flatpak)
            flatpak uninstall -y --user "$@" 2>/dev/null || run_as_root flatpak uninstall -y "$@"
            ;;
        npm)
            npm uninstall -g "$@"
            ;;
        bun)
            bun remove --global "$@"
            ;;
    esac
}

manager_show_info() {
    local manager="$1"
    local package="$2"

    case "${manager}" in
        apt)
            cat <(apt-cache show "${package}" 2>/dev/null) <(printf "\n") <(dpkg -L "${package}" 2>/dev/null)
            ;;
        dnf)
            cat <(dnf info "${package}" 2>/dev/null) <(printf "\n") <(rpm -ql "${package}" 2>/dev/null)
            ;;
        pacman)
            cat <(pacman -Qi "${package}" 2>/dev/null || pacman -Si "${package}" 2>/dev/null) <(printf "\n") <(pacman -Ql "${package}" 2>/dev/null)
            ;;
        zypper)
            zypper --non-interactive info "${package}" 2>/dev/null
            ;;
        emerge)
            emerge --search --color=n "${package}" 2>/dev/null
            ;;
        brew)
            brew info "${package}" 2>/dev/null
            ;;
        winget)
            winget show --id "${package}" --exact --source winget --accept-source-agreements --disable-interactivity 2>/dev/null
            ;;
        choco)
            choco info "${package}" 2>/dev/null
            ;;
        scoop)
            scoop info "${package}" 2>/dev/null
            ;;
        snap)
            snap info "${package}" 2>/dev/null
            ;;
        flatpak)
            flatpak info "${package}" 2>/dev/null || flatpak remote-info flathub "${package}" 2>/dev/null
            ;;
        npm)
            npm view "${package}" 2>/dev/null
            ;;
        bun)
            bun info "${package}" 2>/dev/null || npm view "${package}" 2>/dev/null
            ;;
    esac
}

manager_update() {
    local manager="$1"

    case "${manager}" in
        apt)
            run_as_root apt-get update
            run_as_root apt-get upgrade -y
            ;;
        dnf)
            run_as_root dnf upgrade -y
            ;;
        pacman)
            run_as_root pacman -Syu
            ;;
        zypper)
            run_as_root zypper --non-interactive refresh
            run_as_root zypper --non-interactive update
            ;;
        emerge)
            run_as_root emerge --sync
            run_as_root emerge --ask=n --update --deep --newuse @world
            ;;
        brew)
            brew update
            brew upgrade
            ;;
        winget)
            winget upgrade --all --source winget --accept-package-agreements --accept-source-agreements --disable-interactivity
            ;;
        choco)
            choco upgrade all -y
            ;;
        scoop)
            scoop update
            scoop update "*"
            ;;
        snap)
            run_as_root snap refresh
            ;;
        flatpak)
            flatpak update -y --user 2>/dev/null || run_as_root flatpak update -y
            ;;
        npm)
            npm update -g
            ;;
        bun)
            bun update --global
            ;;
    esac
}

confirm_action() {
    local prompt="$1"
    local reply=""

    printf "%s [y/N]: " "${prompt}" >&2
    read -r reply || true

    case "${reply}" in
        y|Y|yes|YES)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

run_fuzzy_selector() {
    local query="$1"
    local input_file="$2"
    local header_line="$3"
    local reload_cmd="${4:-}"
    local preview_cmd

    preview_cmd='bash -c '\''mgr="$1"; pkg="$2"; case "$mgr" in apt) apt-cache show "$pkg" 2>/dev/null; printf "\n"; dpkg -L "$pkg" 2>/dev/null ;; dnf) dnf info "$pkg" 2>/dev/null; printf "\n"; rpm -ql "$pkg" 2>/dev/null ;; pacman) pacman -Si "$pkg" 2>/dev/null; printf "\n"; pacman -Fl "$pkg" 2>/dev/null | awk "{print \$2}" ;; zypper) zypper --non-interactive info "$pkg" 2>/dev/null ;; emerge) emerge --search --color=n "$pkg" 2>/dev/null ;; brew) brew info "$pkg" 2>/dev/null ;; winget) winget show --id "$pkg" --exact --source winget --accept-source-agreements --disable-interactivity 2>/dev/null ;; choco) choco info "$pkg" 2>/dev/null ;; scoop) scoop info "$pkg" 2>/dev/null ;; snap) snap info "$pkg" 2>/dev/null ;; flatpak) flatpak info "$pkg" 2>/dev/null || flatpak remote-info flathub "$pkg" 2>/dev/null ;; npm) npm view "$pkg" 2>/dev/null ;; bun) bun info "$pkg" 2>/dev/null || npm view "$pkg" 2>/dev/null ;; esac'\'' _ {1} {2}'

    local -a fzf_args=()
    fzf_args=(-q "${query}" -m \
        --delimiter=$'\t' \
        --with-nth=1,2,3 \
        --preview="${preview_cmd}" \
        --preview-window=55%:wrap:border-sharp \
        --layout=reverse \
        --marker='>>' \
        --header="${header_line}" \
        --info=inline-right \
        --ansi \
        --margin="2%,1%,2%,1%" \
        --cycle \
        --tiebreak=begin,chunk,length \
        --bind=ctrl-k:preview:"cat ${KBINDS_FILE}" \
        --bind=ctrl-h:preview:"cat ${HELP_FILE}" \
        --bind='ctrl-/:change-preview-window(hidden|)' \
        --bind=ctrl-n:next-selected,ctrl-b:prev-selected \
        --bind='focus:transform-preview-label:echo [{1}] {2}')

    if [[ -n "${reload_cmd}" ]]; then
        fzf_args+=(--disabled --bind="start:reload:${reload_cmd}" --bind="change:reload:${reload_cmd}")
    else
        fzf_args+=(-e)
    fi

    fzf "${fzf_args[@]}" <"${input_file}"
}

main() {
    ensure_tmp_root
    initialize_session_tmp_root
    trap cleanup_session_tmp_root EXIT

    parse_args "$@"

    if [[ "${ACTION}" == "version" ]]; then
        print_version
        exit 0
    fi

    local detected_manager
    local detected_managers=()
    while IFS= read -r detected_manager; do
        [[ -n "${detected_manager}" ]] || continue
        detected_managers+=("${detected_manager}")
    done < <(detect_default_managers)

    local default_managers_display
    default_managers_display="$(join_manager_labels_with_ids "${detected_managers[@]-}")"
    [[ -n "${default_managers_display}" ]] || default_managers_display="None"

    build_help_file "${default_managers_display}"
    build_keybind_file

    if [[ "${ACTION}" == "help" ]]; then
        print_help
        exit 0
    fi

    local managers=()
    if [[ -n "${MANAGER_OVERRIDE}" ]]; then
        managers+=("$(normalize_manager "${MANAGER_OVERRIDE}")")
    else
        for detected_manager in "${detected_managers[@]-}"; do
            [[ -n "${detected_manager}" ]] || continue
            managers+=("${detected_manager}")
        done
    fi

    if [[ "${#managers[@]}" -eq 0 ]]; then
        die "Unable to auto-detect supported package managers. Use --manager."
    fi

    local manager
    for manager in "${managers[@]-}"; do
        manager_supported "${manager}" || die "Unsupported manager: ${manager}"
        manager_command_ready "${manager}" || die "Manager command(s) for '${manager}' not found on this system"
    done

    local manager_display
    manager_display="$(join_manager_labels "${managers[@]-}")"

    local query
    query="$(join_query)"

    if [[ "${ACTION}" != "feed-search" ]]; then
        log "Using manager(s): ${manager_display}"
    fi

    if [[ "${ACTION}" == "update" ]]; then
        if confirm_action "Run update/upgrade for ${manager_display}?"; then
            for manager in "${managers[@]-}"; do
                log "Updating with $(manager_label "${manager}")"
                manager_update "${manager}"
            done
        else
            log "Update canceled"
        fi
        exit 0
    fi

    local display_file
    display_file="$(mktemp "${SESSION_TMP_ROOT}/display.XXXXXX")"
    : >"${display_file}"

    if [[ "${ACTION}" == "feed-search" ]]; then
        collect_search_display_rows "${query}" "${display_file}" "${managers[@]-}"
        if [[ -s "${display_file}" ]]; then
            cat "${display_file}"
        fi
        rm -f "${display_file}"
        exit 0
    fi

    ensure_fzf "${managers[@]-}"

    if [[ "${ACTION}" == "search" ]]; then
        collect_search_display_rows "${query}" "${display_file}" "${managers[@]-}"
    else
        local part_files=()
        local gather_pids=()
        local part_file
        local gather_pid

        for manager in "${managers[@]-}"; do
        part_file="$(mktemp "${SESSION_TMP_ROOT}/part.XXXXXX")"
        part_files+=("${part_file}")

        (
            local_source_file="$(mktemp "${SESSION_TMP_ROOT}/source.XXXXXX")"
            manager_installed_entries "${manager}" >"${local_source_file}" || true
            if [[ -s "${local_source_file}" ]]; then
                awk -F'\t' -v mgr="${manager}" '
                        NF >= 1 {
                            desc = $2
                            if (desc == "") desc = "-"
                            print mgr "\t" $1 "\t" desc
                        }
                    ' "${local_source_file}" >"${part_file}"
                fi
                rm -f "${local_source_file}"
            ) &
            gather_pids+=("$!")
        done

        for gather_pid in "${gather_pids[@]-}"; do
            wait "${gather_pid}" || true
        done

        for part_file in "${part_files[@]-}"; do
            if [[ -s "${part_file}" ]]; then
                cat "${part_file}" >>"${display_file}"
            fi
            rm -f "${part_file}"
        done

        if [[ -s "${display_file}" ]]; then
            sort -u "${display_file}" -o "${display_file}"
        fi
    fi

    if [[ ! -s "${display_file}" ]]; then
        rm -f "${display_file}"
        if [[ -n "${query}" ]]; then
            die "No packages found for ${manager_display} matching '${query}'. Try a broader query or --manager."
        fi
        die "No packages found for ${manager_display}. Try adding a query or using --manager."
    fi

    local header
    case "${ACTION}" in
        search)
            header="Select package(s) to install with ${manager_display} (TAB to multi-select, * = installed)"
            ;;
        list)
            header="Select installed package(s) to inspect from ${manager_display}"
            ;;
        remove)
            header="Select installed package(s) to remove from ${manager_display}"
            ;;
        *)
            header="Select package(s)"
            ;;
    esac

    local reload_cmd=""
    if [[ "${ACTION}" == "search" && -z "${query}" ]]; then
        reload_cmd="$(build_dynamic_reload_command "${MANAGER_OVERRIDE}")"
    fi

    local selected
    selected="$(run_fuzzy_selector "${query}" "${display_file}" "${header}" "${reload_cmd}" || true)"

    rm -f "${display_file}"

    if [[ -z "${selected}" ]]; then
        log "Selection canceled"
        exit 0
    fi

    local selected_managers=()
    local selected_packages=()
    local selected_line
    local selected_manager
    local selected_pkg
    while IFS= read -r selected_line; do
        [[ -n "${selected_line}" ]] || continue
        IFS=$'\t' read -r selected_manager selected_pkg _ <<<"${selected_line}"
        [[ -n "${selected_manager}" && -n "${selected_pkg}" ]] || continue
        selected_managers+=("${selected_manager}")
        selected_packages+=("${selected_pkg}")
    done <<<"${selected}"

    if [[ "${#selected_packages[@]}" -eq 0 ]]; then
        log "Selection canceled"
        exit 0
    fi

    local unique_managers=()
    local candidate_manager
    local already_seen
    local existing_manager
    for candidate_manager in "${selected_managers[@]-}"; do
        already_seen=0
        for existing_manager in "${unique_managers[@]-}"; do
            if [[ "${existing_manager}" == "${candidate_manager}" ]]; then
                already_seen=1
                break
            fi
        done
        if [[ "${already_seen}" -eq 0 ]]; then
            unique_managers+=("${candidate_manager}")
        fi
    done

    local selected_manager_display
    selected_manager_display="$(join_manager_labels "${unique_managers[@]-}")"

    local idx
    local mgr_packages=()

    case "${ACTION}" in
        search)
            if confirm_action "Install ${#selected_packages[@]} package(s) with ${selected_manager_display}?"; then
                for manager in "${unique_managers[@]-}"; do
                    mgr_packages=()
                    for idx in "${!selected_packages[@]-}"; do
                        if [[ "${selected_managers[$idx]}" == "${manager}" ]]; then
                            mgr_packages+=("${selected_packages[$idx]}")
                        fi
                    done
                    if [[ "${#mgr_packages[@]}" -gt 0 ]]; then
                        log "Installing ${#mgr_packages[@]} package(s) with $(manager_label "${manager}")"
                        manager_install "${manager}" "${mgr_packages[@]-}"
                    fi
                done
            else
                log "Install canceled"
            fi
            ;;
        remove)
            if confirm_action "Remove ${#selected_packages[@]} package(s) with ${selected_manager_display}?"; then
                for manager in "${unique_managers[@]-}"; do
                    mgr_packages=()
                    for idx in "${!selected_packages[@]-}"; do
                        if [[ "${selected_managers[$idx]}" == "${manager}" ]]; then
                            mgr_packages+=("${selected_packages[$idx]}")
                        fi
                    done
                    if [[ "${#mgr_packages[@]}" -gt 0 ]]; then
                        log "Removing ${#mgr_packages[@]} package(s) with $(manager_label "${manager}")"
                        manager_remove "${manager}" "${mgr_packages[@]-}"
                    fi
                done
            else
                log "Remove canceled"
            fi
            ;;
        list)
            for idx in "${!selected_packages[@]-}"; do
                printf "\n=== %s (%s) ===\n" "${selected_packages[$idx]}" "$(manager_label "${selected_managers[$idx]}")"
                manager_show_info "${selected_managers[$idx]}" "${selected_packages[$idx]}" || true
            done
            ;;
    esac
}

main "$@"
