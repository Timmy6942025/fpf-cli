#!/usr/bin/env bash

set -euo pipefail

SCRIPT_NAME="fpf"
TMP_ROOT="${TMPDIR:-/tmp}/fpf"
HELP_FILE="${TMP_ROOT}/help"
KBINDS_FILE="${TMP_ROOT}/keybinds"

ACTION="search"
MANAGER_OVERRIDE=""
declare -a QUERY_PARTS=()

log() {
    printf "%s\n" "$*" >&2
}

die() {
    log "Error: $*"
    exit 1
}

command_exists() {
    command -v "$1" >/dev/null 2>&1
}

ensure_tmp_root() {
    mkdir -p "${TMP_ROOT}"
}

run_as_root() {
    if [[ "${EUID}" -eq 0 ]]; then
        "$@"
        return
    fi

    if command_exists sudo; then
        sudo "$@"
        return
    fi

    die "Root privileges are required for: $*"
}

manager_list() {
    printf "%s\n" "apt dnf pacman zypper emerge brew winget choco scoop snap flatpak npm bun"
}

manager_supported() {
    local manager="$1"
    case "${manager}" in
        apt|dnf|pacman|zypper|emerge|brew|winget|choco|scoop|snap|flatpak|npm|bun)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

manager_command_ready() {
    local manager="$1"
    case "${manager}" in
        apt)
            command_exists apt-cache && command_exists apt-get && command_exists dpkg-query
            ;;
        dnf)
            command_exists dnf
            ;;
        pacman)
            command_exists pacman
            ;;
        zypper)
            command_exists zypper
            ;;
        emerge)
            command_exists emerge
            ;;
        brew)
            command_exists brew
            ;;
        winget)
            command_exists winget
            ;;
        choco)
            command_exists choco
            ;;
        scoop)
            command_exists scoop
            ;;
        snap)
            command_exists snap
            ;;
        flatpak)
            command_exists flatpak
            ;;
        npm)
            command_exists npm
            ;;
        bun)
            command_exists bun
            ;;
        *)
            return 1
            ;;
    esac
}

normalize_manager() {
    printf "%s" "$1" | tr '[:upper:]' '[:lower:]'
}

os_release_field() {
    local file_path="$1"
    local field_name="$2"

    awk -v key="${field_name}" '
        index($0, key "=") == 1 {
            value = substr($0, index($0, "=") + 1)
            gsub(/^[[:space:]]+|[[:space:]]+$/, "", value)
            if (value ~ /^".*"$/ || value ~ /^\047.*\047$/) {
                value = substr(value, 2, length(value) - 2)
            }
            print tolower(value)
            exit
        }
    ' "${file_path}"
}

manager_label() {
    local manager="$1"
    case "${manager}" in
        apt) printf "APT" ;;
        dnf) printf "DNF" ;;
        pacman) printf "Pacman" ;;
        zypper) printf "Zypper" ;;
        emerge) printf "Portage (emerge)" ;;
        brew) printf "Homebrew" ;;
        winget) printf "WinGet" ;;
        choco) printf "Chocolatey" ;;
        scoop) printf "Scoop" ;;
        snap) printf "Snap" ;;
        flatpak) printf "Flatpak" ;;
        npm) printf "npm" ;;
        bun) printf "bun" ;;
        *) printf "%s" "${manager}" ;;
    esac
}

detect_default_manager() {
    local os
    os="$(uname -s)"

    if [[ "${os}" == "Darwin" ]]; then
        if command_exists brew; then
            printf "brew"
            return
        fi
    fi

    if [[ "${os}" == MINGW* || "${os}" == MSYS* || "${os}" == CYGWIN* || "${os}" == "Windows_NT" ]]; then
        if command_exists winget; then printf "winget"; return; fi
        if command_exists choco; then printf "choco"; return; fi
        if command_exists scoop; then printf "scoop"; return; fi
        if command_exists npm; then printf "npm"; return; fi
        if command_exists bun; then printf "bun"; return; fi
    fi

    if [[ "${os}" == "Linux" ]]; then
        local distro_id=""
        local distro_like=""
        local os_release_file="${FPF_OS_RELEASE_FILE:-}"

        if [[ -n "${os_release_file}" && ! -r "${os_release_file}" ]]; then
            die "FPF_OS_RELEASE_FILE is set but not readable: ${os_release_file}"
        fi

        if [[ -z "${os_release_file}" && -r /etc/os-release ]]; then
            os_release_file="/etc/os-release"
        elif [[ -z "${os_release_file}" && -r /usr/lib/os-release ]]; then
            os_release_file="/usr/lib/os-release"
        fi

        if [[ -n "${os_release_file}" ]]; then
            distro_id="$(os_release_field "${os_release_file}" "ID")"
            distro_like="$(os_release_field "${os_release_file}" "ID_LIKE")"
        fi

        case "${distro_id} ${distro_like}" in
            *arch*|*manjaro*)
                if command_exists pacman; then printf "pacman"; return; fi
                ;;
            *ubuntu*|*debian*|*linuxmint*|*pop*|*elementary*)
                if command_exists apt-get; then printf "apt"; return; fi
                ;;
            *fedora*|*rhel*|*centos*|*rocky*|*alma*)
                if command_exists dnf; then printf "dnf"; return; fi
                ;;
            *opensuse*|*suse*|*sles*)
                if command_exists zypper; then printf "zypper"; return; fi
                ;;
            *gentoo*)
                if command_exists emerge; then printf "emerge"; return; fi
                ;;
        esac

        if command_exists apt-get; then printf "apt"; return; fi
        if command_exists dnf; then printf "dnf"; return; fi
        if command_exists pacman; then printf "pacman"; return; fi
        if command_exists zypper; then printf "zypper"; return; fi
        if command_exists emerge; then printf "emerge"; return; fi
        if command_exists snap; then printf "snap"; return; fi
        if command_exists flatpak; then printf "flatpak"; return; fi
        if command_exists npm; then printf "npm"; return; fi
        if command_exists bun; then printf "bun"; return; fi
    fi

    if command_exists brew; then printf "brew"; return; fi
    if command_exists winget; then printf "winget"; return; fi
    if command_exists choco; then printf "choco"; return; fi
    if command_exists scoop; then printf "scoop"; return; fi
    if command_exists npm; then printf "npm"; return; fi
    if command_exists bun; then printf "bun"; return; fi

    die "Unable to auto-detect a supported package manager. Use --manager."
}

detect_default_managers() {
    local os
    local emitted=""
    local primary_manager=""

    add_detected_manager() {
        local manager_name="$1"
        [[ -n "${manager_name}" ]] || return
        case " ${emitted} " in
            *" ${manager_name} "*)
                return
                ;;
        esac
        if manager_command_ready "${manager_name}"; then
            printf "%s\n" "${manager_name}"
            emitted+=" ${manager_name}"
        fi
    }

    os="$(uname -s)"

    if [[ "${os}" == "Darwin" ]]; then
        add_detected_manager "brew"
        add_detected_manager "bun"
        if [[ -n "${emitted}" ]]; then
            return
        fi
    fi

    if [[ "${os}" == MINGW* || "${os}" == MSYS* || "${os}" == CYGWIN* || "${os}" == "Windows_NT" ]]; then
        add_detected_manager "winget"
        add_detected_manager "choco"
        add_detected_manager "scoop"
        add_detected_manager "npm"
        add_detected_manager "bun"
        if [[ -n "${emitted}" ]]; then
            return
        fi
    fi

    if [[ "${os}" == "Linux" ]]; then
        primary_manager="$(detect_default_manager)"
        add_detected_manager "${primary_manager}"

        add_detected_manager "snap"
        add_detected_manager "flatpak"
        add_detected_manager "brew"
        add_detected_manager "npm"
        add_detected_manager "bun"

        if [[ -n "${emitted}" ]]; then
            return
        fi
    fi

    primary_manager="$(detect_default_manager)"
    add_detected_manager "${primary_manager}"

    if [[ -n "${emitted}" ]]; then
        return
    fi

    die "Unable to auto-detect supported package managers. Use --manager."
}

join_manager_labels() {
    local out=""
    local mgr

    for mgr in "$@"; do
        [[ -n "${mgr}" ]] || continue
        if [[ -n "${out}" ]]; then
            out+=", "
        fi
        out+="$(manager_label "${mgr}")"
    done

    printf "%s" "${out}"
}

join_manager_labels_with_ids() {
    local out=""
    local mgr

    for mgr in "$@"; do
        [[ -n "${mgr}" ]] || continue
        if [[ -n "${out}" ]]; then
            out+=", "
        fi
        out+="$(manager_label "${mgr}") (${mgr})"
    done

    printf "%s" "${out}"
}

build_help_file() {
    local default_managers="$1"

    cat >"${HELP_FILE}" <<EOF
${SCRIPT_NAME} - ultimate fuzzy package finder

Syntax:
  ${SCRIPT_NAME} [manager option] [action option] [query]
  ${SCRIPT_NAME} -m|--manager <name> [action option] [query]

Default behavior:
  Fuzzy-search available packages and install selected items.

Detected default manager(s):
  ${default_managers}

Action options:
  -l, --list-installed   Fuzzy-search installed packages and show details
  -R, --remove           Fuzzy-search installed packages and remove selected
  -U, --update           Run manager update/upgrade flow
  -h, --help             Show this help

Manager options (one or two-letter style):
  -ap, --apt             Use APT
  -dn, --dnf             Use DNF
  -pm, --pacman          Use Pacman
  -zy, --zypper          Use Zypper
  -em, --emerge          Use Portage (emerge)
  -br, --brew            Use Homebrew
  -wg, --winget          Use WinGet
  -ch, --choco           Use Chocolatey
  -sc, --scoop           Use Scoop
  -sn, --snap            Use Snap
  -fp, --flatpak         Use Flatpak
  -np, --npm             Use npm (global packages)
  -bn, --bun             Use bun (global packages)
  -ad, --auto            Force auto-detection mode

Examples:
  ${SCRIPT_NAME} docker
  ${SCRIPT_NAME} -dn nginx
  ${SCRIPT_NAME} -ap -l openssl
  ${SCRIPT_NAME} -br -R wget
  ${SCRIPT_NAME} -sn firefox
  ${SCRIPT_NAME} -fp org.gimp.GIMP
  ${SCRIPT_NAME} -wg Microsoft.VisualStudioCode
  ${SCRIPT_NAME} -np eslint
  ${SCRIPT_NAME} -ch git
  ${SCRIPT_NAME} -m apt ripgrep

Supported managers:
  $(manager_list)
EOF
}

build_keybind_file() {
    cat >"${KBINDS_FILE}" <<'EOF'
Keybinds:

  ctrl-h  Show help in preview pane
  ctrl-k  Show keybinds in preview pane
  ctrl-/  Toggle preview pane
  ctrl-n  Move to next selected package
  ctrl-b  Move to previous selected package
EOF
}

print_help() {
    cat "${HELP_FILE}"
}

parse_args() {
    while (($#)); do
        case "$1" in
            -h|--help)
                ACTION="help"
                ;;
            -l|--list-installed)
                ACTION="list"
                ;;
            -R|--remove)
                ACTION="remove"
                ;;
            -U|--update)
                ACTION="update"
                ;;
            -ap|--apt)
                MANAGER_OVERRIDE="apt"
                ;;
            -dn|--dnf)
                MANAGER_OVERRIDE="dnf"
                ;;
            -pm|--pacman)
                MANAGER_OVERRIDE="pacman"
                ;;
            -zy|--zypper)
                MANAGER_OVERRIDE="zypper"
                ;;
            -em|--emerge)
                MANAGER_OVERRIDE="emerge"
                ;;
            -br|--brew)
                MANAGER_OVERRIDE="brew"
                ;;
            -wg|--winget)
                MANAGER_OVERRIDE="winget"
                ;;
            -ch|--choco)
                MANAGER_OVERRIDE="choco"
                ;;
            -sc|--scoop)
                MANAGER_OVERRIDE="scoop"
                ;;
            -sn|--snap)
                MANAGER_OVERRIDE="snap"
                ;;
            -fp|--flatpak)
                MANAGER_OVERRIDE="flatpak"
                ;;
            -np|--npm)
                MANAGER_OVERRIDE="npm"
                ;;
            -bn|--bun)
                MANAGER_OVERRIDE="bun"
                ;;
            -ad|--auto)
                MANAGER_OVERRIDE=""
                ;;
            -m|--manager)
                shift
                [[ $# -gt 0 ]] || die "Missing value for --manager"
                MANAGER_OVERRIDE="$(normalize_manager "$1")"
                ;;
            --)
                shift
                while (($#)); do
                    QUERY_PARTS+=("$1")
                    shift
                done
                break
                ;;
            -*)
                die "Invalid option: $1"
                ;;
            *)
                QUERY_PARTS+=("$1")
                ;;
        esac
        shift
    done
}

join_query() {
    local query=""
    local part

    if (( ${#QUERY_PARTS[@]} == 0 )); then
        printf ""
        return
    fi

    for part in "${QUERY_PARTS[@]-}"; do
        if [[ -z "${query}" ]]; then
            query="${part}"
        else
            query+=" ${part}"
        fi
    done
    printf "%s" "${query}"
}

manager_search_entries() {
    local manager="$1"
    local query="$2"
    local effective_query="${query}"

    if [[ -z "${effective_query}" ]]; then
        case "${manager}" in
            apt|dnf|pacman|zypper|emerge|winget|choco|scoop|snap|flatpak|npm|bun)
                effective_query="a"
                ;;
            brew)
                effective_query=""
                ;;
        esac
    fi

    case "${manager}" in
        apt)
            apt-cache search -- "${effective_query}" 2>/dev/null |
                awk -F' - ' '{ name=$1; desc=$2; gsub(/^[[:space:]]+|[[:space:]]+$/, "", name); if (desc == "") desc="-"; print name "\t" desc }'
            ;;
        dnf)
            local pattern="*"
            if [[ -n "${effective_query}" ]]; then
                pattern="*${effective_query}*"
            fi
            dnf -q list available "${pattern}" 2>/dev/null |
                awk 'NR > 1 && $1 !~ /^(Available|Last|Installed)/ { name=$1; sub(/\.[^.]+$/, "", name); print name "\t" $2 }'
            ;;
        pacman)
            pacman -Ss -- "${effective_query}" 2>/dev/null |
                awk '
                    NR % 2 == 1 {
                        split($1, parts, "/")
                        pkg = parts[2]
                        next
                    }
                    NR % 2 == 0 {
                        line = $0
                        sub(/^[[:space:]]+/, "", line)
                        if (pkg != "") print pkg "\t" line
                    }
                '
            ;;
        zypper)
            zypper --non-interactive --quiet search --details --type package "${effective_query}" 2>/dev/null |
                awk -F'|' '
                    /^[[:space:]]*[ivp ][[:space:]]*\|/ {
                        name=$3
                        ver=$5
                        repo=$7
                        gsub(/^[[:space:]]+|[[:space:]]+$/, "", name)
                        gsub(/^[[:space:]]+|[[:space:]]+$/, "", ver)
                        gsub(/^[[:space:]]+|[[:space:]]+$/, "", repo)
                        if (name != "") print name "\tversion " ver " from " repo
                    }
                '
            ;;
        emerge)
            emerge --searchdesc --color=n "${effective_query}" 2>/dev/null |
                awk '
                    /^\*  / {
                        atom=$2
                        desc="-"
                        next
                    }
                    /^[[:space:]]+Description:/ {
                        line=$0
                        sub(/^[[:space:]]+Description:[[:space:]]*/, "", line)
                        desc=line
                        if (atom != "") print atom "\t" desc
                        atom=""
                    }
                '
            ;;
        brew)
            brew search "${effective_query}" 2>/dev/null |
                awk 'NF > 0 { print $1 "\t-" }'
            ;;
        winget)
            winget search "${effective_query}" --source winget --accept-source-agreements --disable-interactivity 2>/dev/null |
                awk '
                    /^[[:space:]]*$/ { next }
                    /^Name[[:space:]]+Id[[:space:]]+/ { next }
                    /^[-[:space:]]+$/ { next }
                    {
                        pkg = ""
                        desc = "-"
                        if (NF >= 2) {
                            pkg = $2
                        } else if (NF >= 1) {
                            pkg = $1
                        }
                        if (pkg != "") {
                            print pkg "\t" desc
                        }
                    }
                '
            ;;
        choco)
            choco search "${effective_query}" --limit-output 2>/dev/null |
                awk -F'|' 'NF >= 1 && $1 != "" { ver=$2; if (ver == "") ver="-"; print $1 "\tversion " ver }'
            ;;
        scoop)
            scoop search "${effective_query}" 2>/dev/null |
                awk '
                    /^[[:space:]]*$/ { next }
                    /^[-[:space:]]+$/ { next }
                    /^Name[[:space:]]+/ { next }
                    {
                        name = $1
                        $1 = ""
                        sub(/^[[:space:]]+/, "", $0)
                        if ($0 == "") $0 = "-"
                        print name "\t" $0
                    }
                '
            ;;
        snap)
            snap find "${effective_query}" 2>/dev/null |
                awk '
                    NR == 1 { next }
                    NF > 0 {
                        name=$1
                        $1=""
                        sub(/^[[:space:]]+/, "", $0)
                        if ($0 == "") $0 = "-"
                        print name "\t" $0
                    }
                '
            ;;
        flatpak)
            if [[ -z "${effective_query}" ]]; then
                {
                    flatpak remote-ls --app --columns=application,description flathub 2>/dev/null ||
                    flatpak remote-ls --app --columns=application,description 2>/dev/null
                } |
                    awk 'NR > 1 { name=$1; $1=""; sub(/^[[:space:]]+/, "", $0); if ($0 == "") $0="-"; print name "\t" $0 }'
            else
                {
                    flatpak search --columns=application,description "${effective_query}" 2>/dev/null ||
                    flatpak search "${effective_query}" 2>/dev/null
                } |
                    awk 'NR > 1 { name=$1; $1=""; sub(/^[[:space:]]+/, "", $0); if ($0 == "") $0="-"; print name "\t" $0 }'
            fi
            ;;
        npm)
            npm search "${effective_query}" --searchlimit=500 --parseable 2>/dev/null |
                awk -F'\t' 'NF >= 2 { print $1 "\t" $2 }'
            ;;
        bun)
            {
                if bun search "${effective_query}" >/dev/null 2>&1; then
                    bun search "${effective_query}" 2>/dev/null |
                        awk 'NR > 1 && NF > 0 { name=$1; $1=""; sub(/^[[:space:]]+/, "", $0); if ($0 == "") $0="-"; print name "\t" $0 }'
                elif command_exists npm; then
                    npm search "${effective_query}" --searchlimit=500 --parseable 2>/dev/null |
                        awk -F'\t' 'NF >= 2 { print $1 "\t" $2 }'
                fi
            } || true
            ;;
    esac | awk -F'\t' 'NF >= 1 { if ($2 == "") $2 = "-"; print $1 "\t" $2 }' | sort -u || true
}

manager_installed_entries() {
    local manager="$1"

    case "${manager}" in
        apt)
            dpkg-query -W -f='${binary:Package}\t${Version}\n' 2>/dev/null
            ;;
        dnf)
            dnf -q list installed 2>/dev/null |
                awk 'NR > 1 && $1 !~ /^(Installed|Last)/ { name=$1; sub(/\.[^.]+$/, "", name); print name "\t" $2 }'
            ;;
        pacman)
            pacman -Q 2>/dev/null |
                awk '{ print $1 "\t" $2 }'
            ;;
        zypper)
            zypper --non-interactive --quiet search --installed-only --details --type package 2>/dev/null |
                awk -F'|' '
                    /^[[:space:]]*i[[:space:]]*\|/ {
                        name=$3
                        ver=$5
                        gsub(/^[[:space:]]+|[[:space:]]+$/, "", name)
                        gsub(/^[[:space:]]+|[[:space:]]+$/, "", ver)
                        if (name != "") print name "\t" ver
                    }
                '
            ;;
        emerge)
            if command_exists qlist; then
                qlist -ICv 2>/dev/null |
                    awk '{ print $1 "\tinstalled" }'
            else
                local pkg_dir
                for pkg_dir in /var/db/pkg/*/*; do
                    [[ -d "${pkg_dir}" ]] || continue
                    printf "%s\tinstalled\n" "$(basename "${pkg_dir}")"
                done
            fi
            ;;
        brew)
            brew list --versions 2>/dev/null |
                awk '{ name=$1; $1=""; sub(/^[[:space:]]+/, "", $0); if ($0 == "") $0="installed"; print name "\t" $0 }'
            ;;
        winget)
            winget list --source winget --accept-source-agreements --disable-interactivity 2>/dev/null |
                awk '
                    /^[[:space:]]*$/ { next }
                    /^Name[[:space:]]+Id[[:space:]]+/ { next }
                    /^[-[:space:]]+$/ { next }
                    {
                        pkg = ""
                        ver = "installed"
                        if (NF >= 3) {
                            pkg = $2
                            ver = $3
                        } else if (NF >= 2) {
                            pkg = $1
                            ver = $2
                        } else if (NF >= 1) {
                            pkg = $1
                        }
                        if (pkg != "") {
                            print pkg "\t" ver
                        }
                    }
                '
            ;;
        choco)
            choco list --local-only --limit-output 2>/dev/null |
                awk -F'|' 'NF >= 1 && $1 != "" { ver=$2; if (ver == "") ver="installed"; print $1 "\t" ver }'
            ;;
        scoop)
            scoop list 2>/dev/null |
                awk '
                    /^[[:space:]]*$/ { next }
                    /^[-[:space:]]+$/ { next }
                    /^Name[[:space:]]+/ { next }
                    {
                        ver = $2
                        if (ver == "") ver = "installed"
                        print $1 "\t" ver
                    }
                '
            ;;
        snap)
            snap list 2>/dev/null |
                awk 'NR > 1 { print $1 "\t" $2 }'
            ;;
        flatpak)
            flatpak list --app --columns=application,version 2>/dev/null |
                awk 'NR > 1 { print $1 "\t" $2 }'
            ;;
        npm)
            npm ls -g --depth=0 --parseable 2>/dev/null |
                awk -F'/' 'NR > 1 { print $NF "\tglobal" }'
            ;;
        bun)
            {
                if bun pm ls --global >/dev/null 2>&1; then
                    bun pm ls --global 2>/dev/null |
                        awk 'NR > 1 && NF > 0 { print $1 "\tglobal" }'
                elif bun pm ls >/dev/null 2>&1; then
                    bun pm ls 2>/dev/null |
                        awk 'NR > 1 && NF > 0 { print $1 "\tglobal" }'
                elif command_exists npm; then
                    npm ls -g --depth=0 --parseable 2>/dev/null |
                        awk -F'/' 'NR > 1 { print $NF "\tglobal" }'
                fi
            } || true
            ;;
    esac | sort -u || true
}

manager_installed_names() {
    local manager="$1"
    manager_installed_entries "${manager}" | awk -F'\t' 'NF > 0 { print $1 }'
}

mark_installed_packages() {
    local manager="$1"
    local source_file="$2"
    local output_file="$3"
    local installed_file

    installed_file="$(mktemp "${TMP_ROOT}/installed.XXXXXX")"
    manager_installed_names "${manager}" >"${installed_file}" 2>/dev/null || true

    awk -F'\t' '
        FILENAME == ARGV[1] {
            if ($1 != "") {
                installed[$1] = 1
            }
            next
        }
        {
            mark = (installed[$1] ? "* " : "  ")
            desc = $2
            if (desc == "") desc = "-"
            print $1 "\t" mark desc
        }
    ' "${installed_file}" "${source_file}" >"${output_file}"

    rm -f "${installed_file}"
}

manager_preview_command() {
    local manager="$1"

    case "${manager}" in
        apt)
            printf '%s' 'pkg={1}; apt-cache show "$pkg" 2>/dev/null; printf "\n"; dpkg -L "$pkg" 2>/dev/null'
            ;;
        dnf)
            printf '%s' 'pkg={1}; dnf info "$pkg" 2>/dev/null; printf "\n"; rpm -ql "$pkg" 2>/dev/null'
            ;;
        pacman)
            printf '%s' 'pkg={1}; pacman -Si "$pkg" 2>/dev/null; printf "\n"; pacman -Fl "$pkg" 2>/dev/null | awk "{print \$2}"'
            ;;
        zypper)
            printf '%s' 'pkg={1}; zypper --non-interactive info "$pkg" 2>/dev/null'
            ;;
        emerge)
            printf '%s' 'pkg={1}; emerge --search --color=n "$pkg" 2>/dev/null'
            ;;
        brew)
            printf '%s' 'pkg={1}; brew info "$pkg" 2>/dev/null'
            ;;
        winget)
            printf '%s' 'pkg={1}; winget show --id "$pkg" --exact --source winget --accept-source-agreements --disable-interactivity 2>/dev/null'
            ;;
        choco)
            printf '%s' 'pkg={1}; choco info "$pkg" 2>/dev/null'
            ;;
        scoop)
            printf '%s' 'pkg={1}; scoop info "$pkg" 2>/dev/null'
            ;;
        snap)
            printf '%s' 'pkg={1}; snap info "$pkg" 2>/dev/null'
            ;;
        flatpak)
            printf '%s' 'pkg={1}; flatpak info "$pkg" 2>/dev/null || flatpak remote-info flathub "$pkg" 2>/dev/null'
            ;;
        npm)
            printf '%s' 'pkg={1}; npm view "$pkg" 2>/dev/null'
            ;;
        bun)
            printf '%s' 'pkg={1}; bun info "$pkg" 2>/dev/null || npm view "$pkg" 2>/dev/null'
            ;;
    esac
}

manager_install() {
    local manager="$1"
    shift

    case "${manager}" in
        apt)
            run_as_root apt-get install -y "$@"
            ;;
        dnf)
            run_as_root dnf install -y "$@"
            ;;
        pacman)
            run_as_root pacman -S --needed "$@"
            ;;
        zypper)
            run_as_root zypper --non-interactive install --auto-agree-with-licenses "$@"
            ;;
        emerge)
            run_as_root emerge --ask=n --verbose "$@"
            ;;
        brew)
            brew install "$@"
            ;;
        winget)
            local pkg
            for pkg in "$@"; do
                winget install --id "${pkg}" --exact --source winget --accept-package-agreements --accept-source-agreements --disable-interactivity
            done
            ;;
        choco)
            choco install "$@" -y
            ;;
        scoop)
            scoop install "$@"
            ;;
        snap)
            local pkg
            for pkg in "$@"; do
                run_as_root snap install "${pkg}" 2>/dev/null || run_as_root snap install --classic "${pkg}"
            done
            ;;
        flatpak)
            local pkg
            for pkg in "$@"; do
                flatpak install -y --user flathub "${pkg}" 2>/dev/null || flatpak install -y --user "${pkg}"
            done
            ;;
        npm)
            npm install -g "$@"
            ;;
        bun)
            bun add -g "$@"
            ;;
    esac
}

manager_remove() {
    local manager="$1"
    shift

    case "${manager}" in
        apt)
            run_as_root apt-get remove -y "$@"
            ;;
        dnf)
            run_as_root dnf remove -y "$@"
            ;;
        pacman)
            run_as_root pacman -Rsn "$@"
            ;;
        zypper)
            run_as_root zypper --non-interactive remove "$@"
            ;;
        emerge)
            run_as_root emerge --ask=n --deselect "$@"
            run_as_root emerge --ask=n --depclean "$@"
            ;;
        brew)
            brew uninstall "$@"
            ;;
        winget)
            local pkg
            for pkg in "$@"; do
                winget uninstall --id "${pkg}" --exact --disable-interactivity
            done
            ;;
        choco)
            choco uninstall "$@" -y
            ;;
        scoop)
            scoop uninstall "$@"
            ;;
        snap)
            run_as_root snap remove "$@"
            ;;
        flatpak)
            flatpak uninstall -y --user "$@"
            ;;
        npm)
            npm uninstall -g "$@"
            ;;
        bun)
            bun remove --global "$@" 2>/dev/null || bun remove "$@"
            ;;
    esac
}

manager_show_info() {
    local manager="$1"
    local package="$2"

    case "${manager}" in
        apt)
            cat <(apt-cache show "${package}" 2>/dev/null) <(printf "\n") <(dpkg -L "${package}" 2>/dev/null)
            ;;
        dnf)
            cat <(dnf info "${package}" 2>/dev/null) <(printf "\n") <(rpm -ql "${package}" 2>/dev/null)
            ;;
        pacman)
            cat <(pacman -Qi "${package}" 2>/dev/null || pacman -Si "${package}" 2>/dev/null) <(printf "\n") <(pacman -Ql "${package}" 2>/dev/null)
            ;;
        zypper)
            zypper --non-interactive info "${package}" 2>/dev/null
            ;;
        emerge)
            emerge --search --color=n "${package}" 2>/dev/null
            ;;
        brew)
            brew info "${package}" 2>/dev/null
            ;;
        winget)
            winget show --id "${package}" --exact --source winget --accept-source-agreements --disable-interactivity 2>/dev/null
            ;;
        choco)
            choco info "${package}" 2>/dev/null
            ;;
        scoop)
            scoop info "${package}" 2>/dev/null
            ;;
        snap)
            snap info "${package}" 2>/dev/null
            ;;
        flatpak)
            flatpak info "${package}" 2>/dev/null || flatpak remote-info flathub "${package}" 2>/dev/null
            ;;
        npm)
            npm view "${package}" 2>/dev/null
            ;;
        bun)
            bun info "${package}" 2>/dev/null || npm view "${package}" 2>/dev/null
            ;;
    esac
}

manager_update() {
    local manager="$1"

    case "${manager}" in
        apt)
            run_as_root apt-get update
            run_as_root apt-get upgrade -y
            ;;
        dnf)
            run_as_root dnf upgrade -y
            ;;
        pacman)
            run_as_root pacman -Syu
            ;;
        zypper)
            run_as_root zypper --non-interactive refresh
            run_as_root zypper --non-interactive update
            ;;
        emerge)
            run_as_root emerge --sync
            run_as_root emerge --ask=n --update --deep --newuse @world
            ;;
        brew)
            brew update
            brew upgrade
            ;;
        winget)
            winget upgrade --all --source winget --accept-package-agreements --accept-source-agreements --disable-interactivity
            ;;
        choco)
            choco upgrade all -y
            ;;
        scoop)
            scoop update
            scoop update "*"
            ;;
        snap)
            run_as_root snap refresh
            ;;
        flatpak)
            flatpak update -y --user
            ;;
        npm)
            npm update -g
            ;;
        bun)
            bun update --global 2>/dev/null || bun update
            ;;
    esac
}

confirm_action() {
    local prompt="$1"
    local reply=""

    printf "%s [y/N]: " "${prompt}" >&2
    read -r reply || true

    case "${reply}" in
        y|Y|yes|YES)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

run_fuzzy_selector() {
    local query="$1"
    local input_file="$2"
    local header_line="$3"
    local preview_cmd

    preview_cmd='bash -c '\''mgr="$1"; pkg="$2"; case "$mgr" in apt) apt-cache show "$pkg" 2>/dev/null; printf "\n"; dpkg -L "$pkg" 2>/dev/null ;; dnf) dnf info "$pkg" 2>/dev/null; printf "\n"; rpm -ql "$pkg" 2>/dev/null ;; pacman) pacman -Si "$pkg" 2>/dev/null; printf "\n"; pacman -Fl "$pkg" 2>/dev/null | awk "{print \$2}" ;; zypper) zypper --non-interactive info "$pkg" 2>/dev/null ;; emerge) emerge --search --color=n "$pkg" 2>/dev/null ;; brew) brew info "$pkg" 2>/dev/null ;; winget) winget show --id "$pkg" --exact --source winget --accept-source-agreements --disable-interactivity 2>/dev/null ;; choco) choco info "$pkg" 2>/dev/null ;; scoop) scoop info "$pkg" 2>/dev/null ;; snap) snap info "$pkg" 2>/dev/null ;; flatpak) flatpak info "$pkg" 2>/dev/null || flatpak remote-info flathub "$pkg" 2>/dev/null ;; npm) npm view "$pkg" 2>/dev/null ;; bun) bun info "$pkg" 2>/dev/null || npm view "$pkg" 2>/dev/null ;; esac'\'' _ {1} {2}'

    fzf -q "${query}" -e -m \
        --delimiter=$'\t' \
        --with-nth=1,2,3 \
        --preview="${preview_cmd}" \
        --preview-window=55%:wrap:border-sharp \
        --layout=reverse \
        --marker='>>' \
        --header="${header_line}" \
        --info=hidden \
        --margin="2%,1%,2%,1%" \
        --cycle \
        --bind=ctrl-k:preview:"cat ${KBINDS_FILE}" \
        --bind=ctrl-h:preview:"cat ${HELP_FILE}" \
        --bind='ctrl-/:change-preview-window(hidden|)' \
        --bind=ctrl-n:next-selected,ctrl-b:prev-selected \
        --bind='focus:transform-preview-label:echo {1}: {2}' \
        <"${input_file}"
}

main() {
    ensure_tmp_root

    parse_args "$@"

    local detected_manager
    local detected_managers=()
    while IFS= read -r detected_manager; do
        [[ -n "${detected_manager}" ]] || continue
        detected_managers+=("${detected_manager}")
    done < <(detect_default_managers)

    local default_managers_display
    default_managers_display="$(join_manager_labels_with_ids "${detected_managers[@]-}")"
    [[ -n "${default_managers_display}" ]] || default_managers_display="None"

    build_help_file "${default_managers_display}"
    build_keybind_file

    if [[ "${ACTION}" == "help" ]]; then
        print_help
        exit 0
    fi

    local managers=()
    if [[ -n "${MANAGER_OVERRIDE}" ]]; then
        managers+=("$(normalize_manager "${MANAGER_OVERRIDE}")")
    else
        for detected_manager in "${detected_managers[@]-}"; do
            [[ -n "${detected_manager}" ]] || continue
            managers+=("${detected_manager}")
        done
    fi

    if [[ "${#managers[@]}" -eq 0 ]]; then
        die "Unable to auto-detect supported package managers. Use --manager."
    fi

    local manager
    for manager in "${managers[@]-}"; do
        manager_supported "${manager}" || die "Unsupported manager: ${manager}"
        manager_command_ready "${manager}" || die "Manager command(s) for '${manager}' not found on this system"
    done

    local manager_display
    manager_display="$(join_manager_labels "${managers[@]-}")"

    local query
    query="$(join_query)"

    if [[ "${ACTION}" == "update" ]]; then
        log "Using manager(s): ${manager_display}"
        if confirm_action "Run update/upgrade for ${manager_display}?"; then
            for manager in "${managers[@]-}"; do
                log "Updating with $(manager_label "${manager}")"
                manager_update "${manager}"
            done
        else
            log "Update canceled"
        fi
        exit 0
    fi

    command_exists fzf || die "fzf is required"

    local display_file
    display_file="$(mktemp "${TMP_ROOT}/display.XXXXXX")"
    : >"${display_file}"

    local source_file
    local marked_file
    for manager in "${managers[@]-}"; do
        source_file="$(mktemp "${TMP_ROOT}/source.XXXXXX")"

        if [[ "${ACTION}" == "list" || "${ACTION}" == "remove" ]]; then
            manager_installed_entries "${manager}" >"${source_file}" || true
            if [[ -s "${source_file}" ]]; then
                awk -F'\t' -v mgr="${manager}" '
                    NF >= 1 {
                        desc = $2
                        if (desc == "") desc = "-"
                        print mgr "\t" $1 "\t" desc
                    }
                ' "${source_file}" >>"${display_file}"
            fi
            rm -f "${source_file}"
            continue
        fi

        marked_file="$(mktemp "${TMP_ROOT}/marked.XXXXXX")"
        manager_search_entries "${manager}" "${query}" >"${source_file}" || true
        if [[ -s "${source_file}" ]]; then
            mark_installed_packages "${manager}" "${source_file}" "${marked_file}"
            awk -F'\t' -v mgr="${manager}" '
                NF >= 1 {
                    desc = $2
                    if (desc == "") desc = "-"
                    print mgr "\t" $1 "\t" desc
                }
            ' "${marked_file}" >>"${display_file}"
        fi
        rm -f "${source_file}" "${marked_file}"
    done

    if [[ -s "${display_file}" ]]; then
        sort -u "${display_file}" -o "${display_file}"
    fi

    if [[ ! -s "${display_file}" ]]; then
        rm -f "${display_file}"
        die "No packages found for manager(s) '${manager_display}' and query '${query}'"
    fi

    local header
    case "${ACTION}" in
        search)
            header="Select package(s) to install with ${manager_display} (TAB to multi-select)"
            ;;
        list)
            header="Select installed package(s) to inspect from ${manager_display}"
            ;;
        remove)
            header="Select installed package(s) to remove from ${manager_display}"
            ;;
        *)
            header="Select package(s)"
            ;;
    esac

    local selected
    selected="$(run_fuzzy_selector "${query}" "${display_file}" "${header}" || true)"

    rm -f "${display_file}"

    if [[ -z "${selected}" ]]; then
        log "No package selected"
        exit 0
    fi

    local selected_managers=()
    local selected_packages=()
    local selected_line
    local selected_manager
    local selected_pkg
    while IFS= read -r selected_line; do
        [[ -n "${selected_line}" ]] || continue
        IFS=$'\t' read -r selected_manager selected_pkg _ <<<"${selected_line}"
        [[ -n "${selected_manager}" && -n "${selected_pkg}" ]] || continue
        selected_managers+=("${selected_manager}")
        selected_packages+=("${selected_pkg}")
    done <<<"${selected}"

    if [[ "${#selected_packages[@]}" -eq 0 ]]; then
        log "No package selected"
        exit 0
    fi

    local unique_managers=()
    local candidate_manager
    local already_seen
    local existing_manager
    for candidate_manager in "${selected_managers[@]-}"; do
        already_seen=0
        for existing_manager in "${unique_managers[@]-}"; do
            if [[ "${existing_manager}" == "${candidate_manager}" ]]; then
                already_seen=1
                break
            fi
        done
        if [[ "${already_seen}" -eq 0 ]]; then
            unique_managers+=("${candidate_manager}")
        fi
    done

    local selected_manager_display
    selected_manager_display="$(join_manager_labels "${unique_managers[@]-}")"

    local idx
    local mgr_packages=()

    case "${ACTION}" in
        search)
            if confirm_action "Install ${#selected_packages[@]} package(s) with ${selected_manager_display}?"; then
                for manager in "${unique_managers[@]-}"; do
                    mgr_packages=()
                    for idx in "${!selected_packages[@]-}"; do
                        if [[ "${selected_managers[$idx]}" == "${manager}" ]]; then
                            mgr_packages+=("${selected_packages[$idx]}")
                        fi
                    done
                    if [[ "${#mgr_packages[@]}" -gt 0 ]]; then
                        log "Installing ${#mgr_packages[@]} package(s) with $(manager_label "${manager}")"
                        manager_install "${manager}" "${mgr_packages[@]-}"
                    fi
                done
            else
                log "Install canceled"
            fi
            ;;
        remove)
            if confirm_action "Remove ${#selected_packages[@]} package(s) with ${selected_manager_display}?"; then
                for manager in "${unique_managers[@]-}"; do
                    mgr_packages=()
                    for idx in "${!selected_packages[@]-}"; do
                        if [[ "${selected_managers[$idx]}" == "${manager}" ]]; then
                            mgr_packages+=("${selected_packages[$idx]}")
                        fi
                    done
                    if [[ "${#mgr_packages[@]}" -gt 0 ]]; then
                        log "Removing ${#mgr_packages[@]} package(s) with $(manager_label "${manager}")"
                        manager_remove "${manager}" "${mgr_packages[@]-}"
                    fi
                done
            else
                log "Remove canceled"
            fi
            ;;
        list)
            for idx in "${!selected_packages[@]-}"; do
                printf "\n=== %s (%s) ===\n" "${selected_packages[$idx]}" "$(manager_label "${selected_managers[$idx]}")"
                manager_show_info "${selected_managers[$idx]}" "${selected_packages[$idx]}" || true
            done
            ;;
    esac
}

main "$@"
