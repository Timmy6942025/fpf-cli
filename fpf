#!/usr/bin/env bash

set -euo pipefail

SCRIPT_NAME="fpf"
SCRIPT_VERSION="1.6.35"
TMP_ROOT="${TMPDIR:-/tmp}/fpf"
SESSION_TMP_ROOT=""
HELP_FILE=""
KBINDS_FILE=""
CACHE_FORMAT_VERSION="1"
CACHE_ROOT=""
LOADING_INDICATOR_PID=""

ACTION="search"
MANAGER_OVERRIDE=""
IPC_MANAGER_OVERRIDE=""
IPC_FALLBACK_FILE=""
ASSUME_YES="0"
declare -a QUERY_PARTS=()
FPF_LIBRARIES_LOADED="0"

query_cache_flags() {
    printf "%s" "query_limit=${FPF_QUERY_RESULT_LIMIT:-0};per_manager_limit=${FPF_QUERY_PER_MANAGER_LIMIT:-40};no_query_limit=${FPF_NO_QUERY_RESULT_LIMIT:-120};no_query_npm_limit=${FPF_NO_QUERY_NPM_LIMIT:-120}"
}

log() {
    printf "%s\n" "$*" >&2
}

loading_indicator_enabled() {
    local indicator_setting=""

    indicator_setting="$(trim_whitespace "${FPF_LOADING_INDICATOR:-1}")"
    indicator_setting="$(printf "%s" "${indicator_setting}" | tr '[:upper:]' '[:lower:]')"

    case "${indicator_setting}" in
        0|false|no|off)
            return 1
            ;;
    esac

    [[ -t 2 ]]
}

start_loading_indicator() {
    local message="${1:-Loading}"

    if [[ -n "${LOADING_INDICATOR_PID}" ]]; then
        stop_loading_indicator
    fi

    loading_indicator_enabled || return 0

    (
        trap 'exit 0' TERM INT
        local frames='|/-\'
        local frame_index=0
        while true; do
            printf "\r\033[2K%s [%s]" "${message}" "${frames:frame_index:1}" >&2
            frame_index=$(((frame_index + 1) % 4))
            sleep 0.1
        done
    ) &
    LOADING_INDICATOR_PID="$!"
}

stop_loading_indicator() {
    if [[ -z "${LOADING_INDICATOR_PID}" ]]; then
        return 0
    fi

    kill "${LOADING_INDICATOR_PID}" >/dev/null 2>&1 || true
    wait "${LOADING_INDICATOR_PID}" >/dev/null 2>&1 || true
    LOADING_INDICATOR_PID=""

    if loading_indicator_enabled; then
        printf "\r\033[2K" >&2
    fi
}

run_with_loading_indicator() {
    local message="$1"
    shift

    start_loading_indicator "${message}"
    if "$@"; then
        stop_loading_indicator
        return 0
    fi

    local status="$?"
    stop_loading_indicator
    return "${status}"
}

die() {
    log "Error: $*"
    exit 1
}

command_exists() {
    command -v "$1" >/dev/null 2>&1
}

resolve_script_dir() {
    local script_path="${BASH_SOURCE[0]}"
    local script_dir=""

    if command_exists readlink; then
        while [[ -L "${script_path}" ]]; do
            script_dir="$(cd -P "$(dirname "${script_path}")" && pwd)"
            script_path="$(readlink "${script_path}")"
            if [[ "${script_path}" != /* ]]; then
                script_path="${script_dir}/${script_path}"
            fi
        done
    fi

    if [[ "${script_path}" != /* ]]; then
        script_path="$(pwd)/${script_path}"
    fi

    script_dir="$(cd -P "$(dirname "${script_path}")" && pwd)"
    printf "%s" "${script_dir}"
}

load_fpf_libraries() {
    local script_dir=""
    local manager_actions_lib=""

    if [[ "${FPF_LIBRARIES_LOADED}" == "1" ]]; then
        return
    fi

    script_dir="$(resolve_script_dir)"
    manager_actions_lib="${script_dir}/lib/fpf/manager-actions.sh"

    if [[ ! -r "${manager_actions_lib}" ]]; then
        die "Required library file not found: ${manager_actions_lib}"
    fi

    # shellcheck disable=SC1090
    source "${manager_actions_lib}"
    FPF_LIBRARIES_LOADED="1"
}

fzf_command_available() {
    if [[ "${FPF_TEST_FORCE_FZF_MISSING:-0}" == "1" ]]; then
        if [[ -n "${FPF_TEST_MOCK_BIN:-}" && -x "${FPF_TEST_MOCK_BIN}/fzf" ]]; then
            return 0
        fi
        return 1
    fi

    command_exists fzf
}

assume_yes_enabled() {
    local env_assume_yes=""

    if [[ "${ASSUME_YES}" == "1" ]]; then
        return 0
    fi

    env_assume_yes="$(trim_whitespace "${FPF_ASSUME_YES:-0}")"
    env_assume_yes="$(printf "%s" "${env_assume_yes}" | tr '[:upper:]' '[:lower:]')"

    case "${env_assume_yes}" in
        1|true|yes|on)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

ensure_tmp_root() {
    mkdir -p "${TMP_ROOT}"
}

resolve_cache_root() {
    local os
    os="$(uname -s)"

    if [[ -n "${FPF_CACHE_DIR:-}" ]]; then
        printf "%s" "${FPF_CACHE_DIR}"
        return
    fi

    case "${os}" in
        Darwin)
            printf "%s" "${HOME}/Library/Caches/fpf"
            ;;
        Linux)
            if [[ -n "${XDG_CACHE_HOME:-}" ]]; then
                printf "%s" "${XDG_CACHE_HOME}/fpf"
            else
                printf "%s" "${HOME}/.cache/fpf"
            fi
            ;;
        MINGW*|MSYS*|CYGWIN*|Windows_NT)
            if [[ -n "${LOCALAPPDATA:-}" ]]; then
                printf "%s" "${LOCALAPPDATA}/fpf"
            elif [[ -n "${APPDATA:-}" ]]; then
                printf "%s" "${APPDATA}/fpf"
            else
                printf "%s" "${HOME}/.cache/fpf"
            fi
            ;;
        *)
            printf "%s" "${HOME}/.cache/fpf"
            ;;
    esac
}

initialize_cache_root() {
    if [[ -n "${CACHE_ROOT}" ]]; then
        return
    fi

    CACHE_ROOT="$(resolve_cache_root)"
    mkdir -p "${CACHE_ROOT}"
}

normalize_cache_query() {
    printf "%s" "$1" |
        awk '{
            line=$0
            gsub(/^[[:space:]]+|[[:space:]]+$/, "", line)
            gsub(/[[:space:]]+/, " ", line)
            print tolower(line)
        }'
}

trim_whitespace() {
    local value="$1"
    value="${value#"${value%%[![:space:]]*}"}"
    value="${value%"${value##*[![:space:]]}"}"
    printf "%s" "${value}"
}

selection_debug_enabled() {
    case "${FPF_DEBUG_SELECTION:-0}" in
        1|true|yes|on)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

log_selection_parse_skip() {
    local line_number="$1"
    local reason="$2"
    local raw_line="$3"
    local raw_repr=""

    selection_debug_enabled || return 0

    printf -v raw_repr "%q" "${raw_line}"
    log "Debug(selection): skipped line ${line_number}: ${reason}; raw=${raw_repr}"
}

platform_cache_token() {
    uname -s | tr '[:upper:]' '[:lower:]'
}

cache_fingerprint() {
    local manager="$1"
    local query="$2"
    local flags="$3"
    local normalized_query

    normalized_query="$(normalize_cache_query "${query}")"
    printf "%s|%s|%s|%s|%s" "${CACHE_FORMAT_VERSION}" "${manager}" "$(platform_cache_token)" "${normalized_query}" "${flags}"
}

cache_cksum() {
    local input="$1"
    printf "%s" "${input}" | cksum | awk '{ print $1 }'
}

cache_catalog_key() {
    local manager="$1"
    printf "catalog/%s.tsv" "${manager}"
}

catalog_fixture_checksum() {
    local fixture_name="$1"
    local fixture_path=""

    if [[ "${FPF_TEST_FIXTURES:-0}" != "1" ]]; then
        return 1
    fi

    if [[ -z "${FPF_TEST_FIXTURE_DIR:-}" ]]; then
        return 1
    fi

    fixture_path="${FPF_TEST_FIXTURE_DIR}/${fixture_name}"
    [[ -r "${fixture_path}" ]] || return 1
    cksum "${fixture_path}" | awk '{ print $1 }'
}

apt_catalog_state_token() {
    local fixture_checksum=""
    local lists_dir="/var/lib/apt/lists"
    local listing=""
    local listing_checksum=""
    local policy_checksum=""

    fixture_checksum="$(catalog_fixture_checksum "apt-dumpavail.txt" 2>/dev/null || true)"
    if [[ -n "${fixture_checksum}" ]]; then
        printf "fixture=%s" "${fixture_checksum}"
        return
    fi

    if [[ -d "${lists_dir}" ]]; then
        listing="$(find "${lists_dir}" -maxdepth 1 -type f \( -name '*_Packages' -o -name '*_Sources' -o -name '*InRelease' -o -name '*Release' \) -printf '%f|%s|%T@\n' 2>/dev/null | LC_ALL=C sort || true)"
        if [[ -n "${listing}" ]]; then
            listing_checksum="$(printf "%s" "${listing}" | cksum | awk '{ print $1 }')"
            printf "lists=%s" "${listing_checksum}"
            return
        fi
    fi

    if command_exists apt-cache; then
        policy_checksum="$(apt-cache policy 2>/dev/null | cksum | awk '{ print $1 }' || true)"
        if [[ -n "${policy_checksum}" ]]; then
            printf "policy=%s" "${policy_checksum}"
            return
        fi
    fi

    printf "state=unknown"
}

brew_catalog_state_token() {
    local formula_fixture_checksum=""
    local cask_fixture_checksum=""
    local formula_repo=""
    local cask_repo=""
    local formula_head=""
    local cask_head=""
    local brew_version=""

    formula_fixture_checksum="$(catalog_fixture_checksum "brew-formulae.txt" 2>/dev/null || true)"
    cask_fixture_checksum="$(catalog_fixture_checksum "brew-casks.txt" 2>/dev/null || true)"
    if [[ -n "${formula_fixture_checksum}" || -n "${cask_fixture_checksum}" ]]; then
        printf "fixture=formula=%s;cask=%s" "${formula_fixture_checksum:-missing}" "${cask_fixture_checksum:-missing}"
        return
    fi

    if command_exists brew; then
        formula_repo="$(brew --repository 2>/dev/null || true)"
        cask_repo="$(brew --repository homebrew/cask 2>/dev/null || true)"
    fi

    if command_exists git; then
        if [[ -n "${formula_repo}" && -d "${formula_repo}/.git" ]]; then
            formula_head="$(git -C "${formula_repo}" rev-parse HEAD 2>/dev/null || true)"
        fi
        if [[ -n "${cask_repo}" && -d "${cask_repo}/.git" ]]; then
            cask_head="$(git -C "${cask_repo}" rev-parse HEAD 2>/dev/null || true)"
        fi
    fi

    if [[ -n "${formula_head}" || -n "${cask_head}" ]]; then
        printf "repos=formula:%s;cask:%s" "${formula_head:-missing}" "${cask_head:-missing}"
        return
    fi

    if [[ -n "${formula_repo}" || -n "${cask_repo}" ]]; then
        printf "repo-paths=formula:%s;cask:%s" "${formula_repo:-missing}" "${cask_repo:-missing}"
        return
    fi

    if command_exists brew; then
        brew_version="$(brew --version 2>/dev/null | awk 'NR == 1 { print $0; exit }' || true)"
        if [[ -n "${brew_version}" ]]; then
            printf "version=%s" "${brew_version}"
            return
        fi
    fi

    printf "state=unknown"
}

cache_search_catalog_fingerprint() {
    local manager="$1"
    local command_path=""
    local state_token="state=unknown"

    case "${manager}" in
        apt)
            command_path="$(command -v apt-cache 2>/dev/null || printf "missing")"
            state_token="$(apt_catalog_state_token)"
            ;;
        brew)
            command_path="$(command -v brew 2>/dev/null || printf "missing")"
            state_token="$(brew_catalog_state_token)"
            ;;
        *)
            command_path="n/a"
            ;;
    esac

    printf "%s|cmd=%s|%s" "$(cache_fingerprint "${manager}" "" "search-catalog")" "${command_path}" "${state_token}"
}

cache_search_catalog_key() {
    local manager="$1"
    local fingerprint="$2"
    local checksum

    checksum="$(cache_cksum "${fingerprint}")"
    printf "search-catalog/%s/%s.tsv" "${manager}" "${checksum}"
}

cache_query_key() {
    local manager="$1"
    local query="$2"
    local flags="$3"
    local fingerprint
    local checksum

    fingerprint="$(cache_fingerprint "${manager}" "${query}" "${flags}")"
    checksum="$(cache_cksum "${fingerprint}")"
    printf "query/%s/%s.tsv" "${manager}" "${checksum}"
}

cache_meta_key() {
    local key="$1"
    printf "meta/%s.meta" "${key}"
}

cache_path_for_key() {
    local key="$1"
    printf "%s/%s" "${CACHE_ROOT}" "${key}"
}

cache_atomic_write_from_file() {
    local source_file="$1"
    local destination_file="$2"
    local destination_dir
    local destination_base
    local temp_file

    destination_dir="$(dirname "${destination_file}")"
    destination_base="$(basename "${destination_file}")"

    mkdir -p "${destination_dir}"
    temp_file="$(mktemp "${destination_dir}/.${destination_base}.tmp.XXXXXX")"
    cp "${source_file}" "${temp_file}"
    mv "${temp_file}" "${destination_file}"
}

cache_write_meta() {
    local key="$1"
    local fingerprint="$2"
    local item_count="$3"
    local refresh_status="${4:-}"
    local generation="${5:-}"
    local last_error_at="${6:-}"
    local last_error="${7:-}"
    local created_at
    local created_epoch
    local meta_key
    local meta_file
    local temp_meta

    created_at="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
    created_epoch="$(date +%s)"
    meta_key="$(cache_meta_key "${key}")"
    meta_file="$(cache_path_for_key "${meta_key}")"
    temp_meta="$(mktemp "${SESSION_TMP_ROOT}/meta.XXXXXX")"

    {
        printf "format_version=%s\n" "${CACHE_FORMAT_VERSION}"
        printf "created_at=%s\n" "${created_at}"
        printf "created_epoch=%s\n" "${created_epoch}"
        printf "fingerprint=%s\n" "${fingerprint}"
        printf "item_count=%s\n" "${item_count}"
        if [[ -n "${refresh_status}" ]]; then
            printf "refresh_status=%s\n" "${refresh_status}"
        fi
        if [[ -n "${generation}" ]]; then
            printf "generation=%s\n" "${generation}"
        fi
        if [[ -n "${last_error_at}" ]]; then
            printf "last_error_at=%s\n" "${last_error_at}"
        fi
        if [[ -n "${last_error}" ]]; then
            printf "last_error=%s\n" "${last_error}"
        fi
    } >"${temp_meta}"

    cache_atomic_write_from_file "${temp_meta}" "${meta_file}"
    rm -f "${temp_meta}"
}

cache_store_key_from_file() {
    local key="$1"
    local fingerprint="$2"
    local source_file="$3"
    local refresh_status="${4:-}"
    local generation="${5:-}"
    local last_error_at="${6:-}"
    local last_error="${7:-}"
    local cache_file
    local item_count

    cache_file="$(cache_path_for_key "${key}")"
    item_count="$(awk 'END { print NR + 0 }' "${source_file}")"

    cache_atomic_write_from_file "${source_file}" "${cache_file}"
    cache_write_meta "${key}" "${fingerprint}" "${item_count}" "${refresh_status}" "${generation}" "${last_error_at}" "${last_error}"
}

cache_meta_value_for_key() {
    local key="$1"
    local field_name="$2"
    local meta_file

    meta_file="$(cache_path_for_key "$(cache_meta_key "${key}")")"
    if [[ ! -r "${meta_file}" ]]; then
        return 1
    fi

    awk -F'=' -v key="${field_name}" '$1 == key { value=substr($0, index($0, "=") + 1); print value; exit }' "${meta_file}"
}

cache_is_fresh_with_ttl() {
    local key="$1"
    local ttl_seconds="$2"
    local created_epoch
    local now_epoch
    local age_seconds

    if ! [[ "${ttl_seconds}" =~ ^[0-9]+$ ]]; then
        return 1
    fi

    if [[ "${ttl_seconds}" -eq 0 ]]; then
        return 1
    fi

    created_epoch="$(cache_meta_value_for_key "${key}" "created_epoch" 2>/dev/null || true)"
    if ! [[ "${created_epoch}" =~ ^[0-9]+$ ]]; then
        return 1
    fi

    now_epoch="$(date +%s)"
    if ! [[ "${now_epoch}" =~ ^[0-9]+$ ]]; then
        return 1
    fi

    age_seconds=$((now_epoch - created_epoch))
    if [[ "${age_seconds}" -lt 0 ]]; then
        return 1
    fi

    [[ "${age_seconds}" -lt "${ttl_seconds}" ]]
}

cache_emit_query_rows_if_valid() {
    local cache_file="$1"

    [[ -s "${cache_file}" ]] || return 1

    if ! awk -F'\t' 'NF >= 2 && $1 != "" { next } { exit 1 } END { if (NR == 0) exit 1 }' "${cache_file}" >/dev/null 2>&1; then
        return 1
    fi

    awk -F'\t' 'NF >= 2 && $1 != "" { desc=$2; if (desc == "") desc="-"; print $1 "\t" desc }' "${cache_file}"
}

bun_generation_state_key() {
    local key="$1"
    printf "state/%s.generation" "${key}"
}

bun_generation_read() {
    local key="$1"
    local state_file
    local current="0"

    state_file="$(cache_path_for_key "$(bun_generation_state_key "${key}")")"
    if [[ -r "${state_file}" ]]; then
        current="$(awk 'NR == 1 { print $1; exit }' "${state_file}")"
    fi

    if ! [[ "${current}" =~ ^[0-9]+$ ]]; then
        current="0"
    fi

    printf "%s" "${current}"
}

bun_generation_write() {
    local key="$1"
    local generation="$2"
    local state_key
    local state_file
    local temp_file

    state_key="$(bun_generation_state_key "${key}")"
    state_file="$(cache_path_for_key "${state_key}")"
    temp_file="$(mktemp "${SESSION_TMP_ROOT}/bun-generation.XXXXXX")"
    printf "%s\n" "${generation}" >"${temp_file}"
    cache_atomic_write_from_file "${temp_file}" "${state_file}"
    rm -f "${temp_file}"
}

bun_generation_next() {
    local key="$1"
    local current
    local next

    current="$(bun_generation_read "${key}")"
    next=$((current + 1))
    bun_generation_write "${key}" "${next}"
    printf "%s" "${next}"
}

bun_refresh_idle_seconds() {
    local idle_seconds="${FPF_BUN_REFRESH_IDLE:-0.12}"
    if ! [[ "${idle_seconds}" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
        idle_seconds="0.12"
    fi
    printf "%s" "${idle_seconds}"
}

bun_emit_refresh_failure_meta() {
    local key="$1"
    local fingerprint="$2"
    local generation="$3"
    local last_error="$4"
    local cache_file
    local item_count="0"
    local last_error_at

    cache_file="$(cache_path_for_key "${key}")"
    if [[ -s "${cache_file}" ]]; then
        item_count="$(awk 'END { print NR + 0 }' "${cache_file}")"
    fi

    last_error_at="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
    cache_write_meta "${key}" "${fingerprint}" "${item_count}" "error" "${generation}" "${last_error_at}" "${last_error}"
}

bun_try_hot_reload_after_refresh() {
    local query="$1"

    if [[ -n "${FPF_BUN_REFRESH_MANAGER_OVERRIDE:-}" || -n "${FPF_BUN_REFRESH_FALLBACK_FILE:-}" ]]; then
        FPF_BUN_SKIP_REFRESH_SCHEDULE=1 \
            FPF_IPC_MANAGER_OVERRIDE="${FPF_BUN_REFRESH_MANAGER_OVERRIDE:-}" \
            FPF_IPC_FALLBACK_FILE="${FPF_BUN_REFRESH_FALLBACK_FILE:-}" \
            run_ipc_reload_action "${query}" || true
    fi

    if [[ -n "${FPF_TEST_CACHE_REFRESH_SIGNAL_FILE:-}" ]] && command_exists fpf-refresh-signal; then
        fpf-refresh-signal >/dev/null 2>&1 || true
    fi
}

bun_run_refresh_worker() {
    local manager="$1"
    local query="$2"
    local flags="$3"
    local key="$4"
    local fingerprint="$5"
    local generation="$6"
    local output_tmp

    sleep "$(bun_refresh_idle_seconds)"

    if [[ "${generation}" != "$(bun_generation_read "${key}")" ]]; then
        return 0
    fi

    output_tmp="$(mktemp "${SESSION_TMP_ROOT}/bun-refresh.XXXXXX")"
    if ! manager_bun_search_entries_strict "${query}" >"${output_tmp}"; then
        rm -f "${output_tmp}"
        bun_emit_refresh_failure_meta "${key}" "${fingerprint}" "${generation}" "bun_search_failed"
        send_fzf_prompt_action "Search> " || true
        return 1
    fi

    if [[ "${generation}" != "$(bun_generation_read "${key}")" ]]; then
        rm -f "${output_tmp}"
        return 0
    fi

    cache_store_key_from_file "${key}" "${fingerprint}" "${output_tmp}" "success" "${generation}"
    rm -f "${output_tmp}"
    bun_try_hot_reload_after_refresh "${query}"
    return 0
}

start_bun_refresh_worker_async() {
    local manager="$1"
    local query="$2"
    local flags="$3"
    local key="$4"
    local fingerprint="$5"
    local generation="$6"
    local fallback_file="$7"
    local manager_override="$8"
    local script_path="${BASH_SOURCE[0]}"

    if [[ "${script_path}" != /* ]]; then
        script_path="$(pwd)/${script_path}"
    fi

    FPF_BUN_REFRESH_FLAGS="${flags}" \
        FPF_BUN_REFRESH_KEY="${key}" \
        FPF_BUN_REFRESH_FINGERPRINT="${fingerprint}" \
        FPF_BUN_REFRESH_GENERATION="${generation}" \
        FPF_BUN_REFRESH_FALLBACK_FILE="${fallback_file}" \
        FPF_BUN_REFRESH_MANAGER_OVERRIDE="${manager_override}" \
        "${script_path}" --bun-refresh-worker --manager "${manager}" -- "${query}" >/dev/null 2>&1 &
}

build_apt_catalog_entries() {
    apt-cache dumpavail 2>/dev/null |
        awk '
            function flush_entry() {
                if (pkg == "") {
                    return
                }
                desc_out = desc
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", desc_out)
                if (desc_out == "") {
                    desc_out = "-"
                }
                print pkg "\t" desc_out
            }

            /^Package:[[:space:]]*/ {
                flush_entry()
                pkg = $0
                sub(/^Package:[[:space:]]*/, "", pkg)
                desc = ""
                next
            }

            /^Description:[[:space:]]*/ {
                desc = $0
                sub(/^Description:[[:space:]]*/, "", desc)
                next
            }

            /^[[:space:]]+/ {
                if (desc != "") {
                    line = $0
                    sub(/^[[:space:]]+/, "", line)
                    if (line != "") {
                        desc = desc " " line
                    }
                }
                next
            }

            /^$/ {
                flush_entry()
                pkg = ""
                desc = ""
                next
            }

            END {
                flush_entry()
            }
        ' |
        awk -F'\t' 'NF >= 1 && $1 != "" { if ($2 == "") $2 = "-"; print $1 "\t" $2 }' |
        awk -F'\t' '!seen[$1]++'
}

build_brew_catalog_entries() {
    {
        brew formulae 2>/dev/null || true
        brew casks 2>/dev/null || true
    } |
        awk 'NF >= 1 && $1 != "" { print $1 "\t-" }' |
        awk -F'\t' '!seen[$1]++'
}

ensure_search_catalog_cache() {
    local manager="$1"
    local cache_fingerprint_value
    local cache_key
    local cache_file
    local output_tmp

    initialize_cache_root

    cache_fingerprint_value="$(cache_search_catalog_fingerprint "${manager}")"
    cache_key="$(cache_search_catalog_key "${manager}" "${cache_fingerprint_value}")"
    cache_file="$(cache_path_for_key "${cache_key}")"

    if [[ -s "${cache_file}" ]]; then
        return 0
    fi

    output_tmp="$(mktemp "${SESSION_TMP_ROOT}/search-catalog.XXXXXX")"

    case "${manager}" in
        apt)
            build_apt_catalog_entries >"${output_tmp}" || true
            ;;
        brew)
            build_brew_catalog_entries >"${output_tmp}" || true
            ;;
        *)
            rm -f "${output_tmp}"
            return 1
            ;;
    esac

    if [[ -s "${output_tmp}" ]]; then
        cache_store_key_from_file "${cache_key}" "${cache_fingerprint_value}" "${output_tmp}"
        rm -f "${output_tmp}"
        return 0
    fi

    rm -f "${output_tmp}"
    return 1
}

search_entries_from_catalog_cache() {
    local manager="$1"
    local query="$2"
    local cache_fingerprint_value
    local cache_key
    local cache_file

    initialize_cache_root

    cache_fingerprint_value="$(cache_search_catalog_fingerprint "${manager}")"
    cache_key="$(cache_search_catalog_key "${manager}" "${cache_fingerprint_value}")"
    cache_file="$(cache_path_for_key "${cache_key}")"

    if [[ ! -s "${cache_file}" ]]; then
        return 1
    fi

    awk -F'\t' -v query="${query}" '
        BEGIN {
            normalized = tolower(query)
            token_count = split(normalized, raw_tokens, /[[:space:]]+/)
            token_index = 0
            for (i = 1; i <= token_count; i++) {
                if (raw_tokens[i] != "") {
                    token_index++
                    tokens[token_index] = raw_tokens[i]
                }
            }
        }
        {
            haystack = tolower($1 " " $2)
            matched = 1
            for (i = 1; i <= token_index; i++) {
                if (index(haystack, tokens[i]) == 0) {
                    matched = 0
                    break
                }
            }
            if (matched) {
                desc = $2
                if (desc == "") {
                    desc = "-"
                }
                print $1 "\t" desc
            }
        }
    ' "${cache_file}" || return 1
}

initialize_session_tmp_root() {
    if [[ -n "${SESSION_TMP_ROOT}" ]]; then
        return
    fi

    if [[ -n "${FPF_SESSION_TMP_ROOT:-}" ]]; then
        SESSION_TMP_ROOT="${FPF_SESSION_TMP_ROOT}"
        mkdir -p "${SESSION_TMP_ROOT}"
    else
        SESSION_TMP_ROOT="$(mktemp -d "${TMP_ROOT}/session.XXXXXX")"
    fi
    HELP_FILE="${SESSION_TMP_ROOT}/help"
    KBINDS_FILE="${SESSION_TMP_ROOT}/keybinds"
}

run_preview_manager_output() {
    local manager="$1"
    local package="$2"

    manager_show_info "${manager}" "${package}" || true
}

run_preview_item_action() {
    local manager="$1"
    local package="$2"
    local cache_dir="${SESSION_TMP_ROOT}/preview-cache"
    local cache_key=""
    local cache_file=""
    local temp_file=""

    [[ -n "${manager}" && -n "${package}" ]] || return 0

    mkdir -p "${cache_dir}"
    cache_key="$(cache_cksum "${manager}|${package}")"
    cache_file="${cache_dir}/${manager}.${cache_key}.txt"

    if [[ -f "${cache_file}" ]]; then
        cat "${cache_file}"
        return 0
    fi

    temp_file="$(mktemp "${SESSION_TMP_ROOT}/preview.XXXXXX")"
    run_preview_manager_output "${manager}" "${package}" >"${temp_file}"
    mv -f "${temp_file}" "${cache_file}"
    cat "${cache_file}"
}

cleanup_session_tmp_root() {
    stop_loading_indicator

    if [[ -n "${SESSION_TMP_ROOT}" && -d "${SESSION_TMP_ROOT}" ]]; then
        rm -rf "${SESSION_TMP_ROOT}"
    fi
}

run_as_root() {
    if [[ "${EUID}" -eq 0 ]]; then
        "$@"
        return
    fi

    if command_exists sudo; then
        sudo "$@"
        return
    fi

    die "Root privileges are required for: $*"
}

manager_list() {
    printf "%s\n" "apt dnf pacman zypper emerge brew winget choco scoop snap flatpak npm bun"
}

manager_supported() {
    local manager="$1"
    case "${manager}" in
        apt|dnf|pacman|zypper|emerge|brew|winget|choco|scoop|snap|flatpak|npm|bun)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

manager_command_ready() {
    local manager="$1"
    case "${manager}" in
        apt)
            command_exists apt-cache && command_exists apt-get && command_exists dpkg-query
            ;;
        dnf)
            command_exists dnf
            ;;
        pacman)
            command_exists pacman
            ;;
        zypper)
            command_exists zypper
            ;;
        emerge)
            command_exists emerge
            ;;
        brew)
            command_exists brew
            ;;
        winget)
            command_exists winget
            ;;
        choco)
            command_exists choco
            ;;
        scoop)
            command_exists scoop
            ;;
        snap)
            command_exists snap
            ;;
        flatpak)
            command_exists flatpak
            ;;
        npm)
            command_exists npm
            ;;
        bun)
            command_exists bun
            ;;
        *)
            return 1
            ;;
    esac
}

flatpak_has_any_remotes() {
    if ! manager_command_ready flatpak; then
        return 1
    fi

    if flatpak remotes --columns=name 2>/dev/null | awk 'NF > 0 { found=1; exit } END { exit (found ? 0 : 1) }'; then
        return 0
    fi

    if flatpak remote-list --columns=name 2>/dev/null | awk 'NF > 0 { found=1; exit } END { exit (found ? 0 : 1) }'; then
        return 0
    fi

    return 1
}

flatpak_has_flathub_remote() {
    if ! manager_command_ready flatpak; then
        return 1
    fi

    if flatpak remotes --columns=name 2>/dev/null | awk '{
        name=tolower($1)
        if (name == "flathub") {
            found=1
            exit
        }
    } END { exit (found ? 0 : 1) }'; then
        return 0
    fi

    if flatpak remote-list --columns=name 2>/dev/null | awk '{
        name=tolower($1)
        if (name == "flathub") {
            found=1
            exit
        }
    } END { exit (found ? 0 : 1) }'; then
        return 0
    fi

    return 1
}

ensure_flatpak_flathub_remote() {
    if ! manager_command_ready flatpak; then
        return 1
    fi

    if flatpak_has_flathub_remote; then
        return 0
    fi

    flatpak remote-add --if-not-exists --user flathub https://flathub.org/repo/flathub.flatpakrepo 2>/dev/null ||
        run_as_root flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo 2>/dev/null ||
        return 1

    flatpak_has_flathub_remote
}

winget_has_default_source() {
    if ! manager_command_ready winget; then
        return 1
    fi

    if winget source list 2>/dev/null | awk '
        {
            line=$0
            sub(/^[[:space:]]+/, "", line)
            if (line == "") {
                next
            }
            split(line, cols, /[[:space:]]+/)
            if (tolower(cols[1]) == "winget") {
                found=1
                exit
            }
        }
        END { exit (found ? 0 : 1) }
    '; then
        return 0
    fi

    return 1
}

choco_has_any_sources() {
    if ! manager_command_ready choco; then
        return 1
    fi

    if choco source list --limit-output 2>/dev/null | awk -F'|' 'NF >= 2 && $1 != "" { found=1; exit } END { exit (found ? 0 : 1) }'; then
        return 0
    fi

    return 1
}

scoop_has_any_buckets() {
    if ! manager_command_ready scoop; then
        return 1
    fi

    if scoop bucket list 2>/dev/null | awk '
        {
            line=$0
            sub(/^[[:space:]]+/, "", line)
            if (line == "") {
                next
            }
            if (tolower(line) ~ /^name[[:space:]]+/) {
                next
            }
            if (line ~ /^[-[:space:]]+$/) {
                next
            }
            split(line, cols, /[[:space:]]+/)
            if (length(cols[2]) > 0 && (cols[2] ~ /^https?:\/\// || cols[2] ~ /^git@/ || cols[2] ~ /^ssh:\/\// || cols[2] ~ /^file:\/\// || cols[2] ~ /^\//)) {
                found=1
                exit
            }
        }
        END { exit (found ? 0 : 1) }
    '; then
        return 0
    fi

    return 1
}

manager_no_query_setup_message() {
    local manager="$1"

    case "${manager}" in
        flatpak)
            if ! flatpak_has_flathub_remote; then
                ensure_flatpak_flathub_remote >/dev/null 2>&1 || true
            fi
            if ! flatpak_has_flathub_remote; then
                printf "%s" "Flatpak has no remotes configured. Add Flathub with: flatpak remote-add --if-not-exists --user flathub https://flathub.org/repo/flathub.flatpakrepo"
                return 0
            fi
            ;;
        winget)
            if ! winget_has_default_source; then
                printf "%s" "WinGet source 'winget' is not configured. Restore it with: winget source reset --force"
                return 0
            fi
            ;;
        choco)
            if ! choco_has_any_sources; then
                printf "%s" "Chocolatey has no package sources configured. Add the default source with: choco source add -n=chocolatey -s=https://community.chocolatey.org/api/v2/"
                return 0
            fi
            ;;
        scoop)
            if ! scoop_has_any_buckets; then
                printf "%s" "Scoop has no buckets configured. Add the default bucket with: scoop bucket add main"
                return 0
            fi
            ;;
    esac

    return 1
}

manager_can_install_fzf() {
    local manager="$1"
    case "${manager}" in
        apt|dnf|pacman|zypper|emerge|brew|winget|choco|scoop|snap)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

install_fzf_with_manager() {
    local manager="$1"

    if [[ "${FPF_TEST_FZF_MANAGER_INSTALL_FAIL:-0}" == "1" ]]; then
        return 1
    fi

    case "${manager}" in
        apt)
            run_as_root apt-get install -y fzf
            ;;
        dnf)
            run_as_root dnf install -y fzf
            ;;
        pacman)
            run_as_root pacman -S --needed fzf
            ;;
        zypper)
            run_as_root zypper --non-interactive install --auto-agree-with-licenses fzf
            ;;
        emerge)
            run_as_root emerge --ask=n app-shells/fzf
            ;;
        brew)
            brew install fzf
            ;;
        winget)
            winget install --id junegunn.fzf --exact --source winget --accept-package-agreements --accept-source-agreements --disable-interactivity ||
                winget install --id fzf --exact --source winget --accept-package-agreements --accept-source-agreements --disable-interactivity
            ;;
        choco)
            choco install fzf -y
            ;;
        scoop)
            scoop install fzf
            ;;
        snap)
            run_as_root snap install fzf
            ;;
        *)
            return 1
            ;;
    esac
}

detect_fzf_release_asset() {
    local os=""
    local arch=""

    os="$(uname -s)"
    arch="$(uname -m)"

    case "${os}" in
        Linux)
            case "${arch}" in
                x86_64|amd64) printf "linux_amd64.tar.gz" ;;
                aarch64|arm64) printf "linux_arm64.tar.gz" ;;
                armv7l|armv7*) printf "linux_armv7.tar.gz" ;;
                armv6l|armv6*) printf "linux_armv6.tar.gz" ;;
                *) return 1 ;;
            esac
            ;;
        Darwin)
            case "${arch}" in
                x86_64|amd64) printf "darwin_amd64.tar.gz" ;;
                arm64|aarch64) printf "darwin_arm64.tar.gz" ;;
                *) return 1 ;;
            esac
            ;;
        *)
            return 1
            ;;
    esac
}

resolve_fzf_release_url() {
    local asset_suffix="$1"
    local api_url="https://api.github.com/repos/junegunn/fzf/releases/latest"
    local api_payload=""
    local asset_url=""

    if [[ -n "${FPF_FZF_BOOTSTRAP_URL:-}" ]]; then
        printf "%s" "${FPF_FZF_BOOTSTRAP_URL}"
        return 0
    fi

    command_exists curl || return 1
    api_payload="$(curl --silent --show-error --fail --location "${api_url}" 2>/dev/null || true)"
    [[ -n "${api_payload}" ]] || return 1

    asset_url="$(printf "%s" "${api_payload}" | awk -F'"' -v suffix="${asset_suffix}" '
        $2 == "browser_download_url" {
            needle = "-" suffix
            if (index($4, needle) > 0) {
                print $4
                exit
            }
        }
    ')"

    [[ -n "${asset_url}" ]] || return 1
    printf "%s" "${asset_url}"
}

install_fzf_from_release_fallback() {
    local asset_suffix=""
    local asset_url=""
    local archive_file=""
    local install_dir=""

    if [[ "${FPF_TEST_BOOTSTRAP_FZF_FALLBACK:-0}" == "1" ]]; then
        if [[ -n "${FPF_TEST_MOCKCMD_PATH:-}" && -n "${FPF_TEST_MOCK_BIN:-}" ]]; then
            ln -sf "${FPF_TEST_MOCKCMD_PATH}" "${FPF_TEST_MOCK_BIN}/fzf"
            return 0
        fi
        return 1
    fi

    asset_suffix="$(detect_fzf_release_asset)" || return 1
    asset_url="$(resolve_fzf_release_url "${asset_suffix}")" || return 1
    archive_file="$(mktemp "${SESSION_TMP_ROOT}/fzf-bootstrap.XXXXXX.tar.gz")"
    install_dir="${SESSION_TMP_ROOT}/fzf-bootstrap/bin"

    mkdir -p "${install_dir}"

    if ! curl --silent --show-error --fail --location --output "${archive_file}" "${asset_url}"; then
        rm -f "${archive_file}"
        return 1
    fi

    if ! tar -xzf "${archive_file}" -C "${install_dir}"; then
        rm -f "${archive_file}"
        return 1
    fi

    rm -f "${archive_file}"
    chmod +x "${install_dir}/fzf" 2>/dev/null || true
    [[ -x "${install_dir}/fzf" ]] || return 1

    PATH="${install_dir}:${PATH}"
    export PATH
    return 0
}

build_fzf_bootstrap_candidates() {
    local seen=""
    local manager

    for manager in "$@"; do
        [[ -n "${manager}" ]] || continue
        manager_can_install_fzf "${manager}" || continue
        manager_command_ready "${manager}" || continue
        case " ${seen} " in
            *" ${manager} "*)
                continue
                ;;
        esac
        printf "%s\n" "${manager}"
        seen+=" ${manager}"
    done

    if [[ -n "${seen}" ]]; then
        return
    fi

    for manager in apt dnf pacman zypper emerge brew winget choco scoop snap; do
        manager_command_ready "${manager}" || continue
        case " ${seen} " in
            *" ${manager} "*)
                continue
                ;;
        esac
        printf "%s\n" "${manager}"
        seen+=" ${manager}"
    done
}

ensure_fzf() {
    local candidates=()
    local manager

    if fzf_command_available; then
        return
    fi

    while IFS= read -r manager; do
        [[ -n "${manager}" ]] || continue
        candidates+=("${manager}")
    done < <(build_fzf_bootstrap_candidates "$@")

    if [[ "${#candidates[@]}" -eq 0 ]]; then
        die "fzf is required and no compatible manager is available to auto-install it"
    fi

    local candidate_labels
    candidate_labels="$(join_manager_labels "${candidates[@]-}")"

    log "fzf is missing. Auto-installing with: ${candidate_labels}"

    for manager in "${candidates[@]-}"; do
        log "Attempting fzf install with $(manager_label "${manager}")"
        if install_fzf_with_manager "${manager}"; then
            if fzf_command_available; then
                return
            fi
        fi
    done

    log "Package-manager bootstrap did not provide fzf. Trying release binary fallback."
    if install_fzf_from_release_fallback && fzf_command_available; then
        return
    fi

    die "Failed to auto-install fzf. Install fzf manually and rerun."
}

normalize_manager() {
    local manager="$1"

    manager="$(trim_whitespace "${manager}")"
    manager="$(printf "%s" "${manager}" | tr '[:upper:]' '[:lower:]')"

    case "${manager}" in
        homebrew)
            manager="brew"
            ;;
        chocolatey|chocolate)
            manager="choco"
            ;;
        "portage (emerge)"|portage-emerge|portage)
            manager="emerge"
            ;;
        win-get)
            manager="winget"
            ;;
    esac

    printf "%s" "${manager}"
}

os_release_field() {
    local file_path="$1"
    local field_name="$2"

    awk -v key="${field_name}" '
        index($0, key "=") == 1 {
            value = substr($0, index($0, "=") + 1)
            gsub(/^[[:space:]]+|[[:space:]]+$/, "", value)
            if (value ~ /^".*"$/ || value ~ /^\047.*\047$/) {
                value = substr(value, 2, length(value) - 2)
            }
            print tolower(value)
            exit
        }
    ' "${file_path}"
}

manager_label() {
    local manager="$1"
    case "${manager}" in
        apt) printf "APT" ;;
        dnf) printf "DNF" ;;
        pacman) printf "Pacman" ;;
        zypper) printf "Zypper" ;;
        emerge) printf "Portage (emerge)" ;;
        brew) printf "Homebrew" ;;
        winget) printf "WinGet" ;;
        choco) printf "Chocolatey" ;;
        scoop) printf "Scoop" ;;
        snap) printf "Snap" ;;
        flatpak) printf "Flatpak" ;;
        npm) printf "npm" ;;
        bun) printf "bun" ;;
        *) printf "%s" "${manager}" ;;
    esac
}

detect_default_manager() {
    local os
    os="$(uname -s)"

    if [[ "${os}" == "Darwin" ]]; then
        if command_exists brew; then
            printf "brew"
            return
        fi
    fi

    if [[ "${os}" == MINGW* || "${os}" == MSYS* || "${os}" == CYGWIN* || "${os}" == "Windows_NT" ]]; then
        if command_exists winget; then printf "winget"; return; fi
        if command_exists choco; then printf "choco"; return; fi
        if command_exists scoop; then printf "scoop"; return; fi
        if command_exists bun; then printf "bun"; return; fi
        if command_exists npm; then printf "npm"; return; fi
    fi

    if [[ "${os}" == "Linux" ]]; then
        local distro_id=""
        local distro_like=""
        local os_release_file="${FPF_OS_RELEASE_FILE:-}"

        if [[ -n "${os_release_file}" && ! -r "${os_release_file}" ]]; then
            die "FPF_OS_RELEASE_FILE is set but not readable: ${os_release_file}"
        fi

        if [[ -z "${os_release_file}" && -r /etc/os-release ]]; then
            os_release_file="/etc/os-release"
        elif [[ -z "${os_release_file}" && -r /usr/lib/os-release ]]; then
            os_release_file="/usr/lib/os-release"
        fi

        if [[ -n "${os_release_file}" ]]; then
            distro_id="$(os_release_field "${os_release_file}" "ID")"
            distro_like="$(os_release_field "${os_release_file}" "ID_LIKE")"
        fi

        case "${distro_id} ${distro_like}" in
            *arch*|*manjaro*)
                if command_exists pacman; then printf "pacman"; return; fi
                ;;
            *ubuntu*|*debian*|*linuxmint*|*pop*|*elementary*)
                if command_exists apt-get; then printf "apt"; return; fi
                ;;
            *fedora*|*rhel*|*centos*|*rocky*|*alma*)
                if command_exists dnf; then printf "dnf"; return; fi
                ;;
            *opensuse*|*suse*|*sles*)
                if command_exists zypper; then printf "zypper"; return; fi
                ;;
            *gentoo*)
                if command_exists emerge; then printf "emerge"; return; fi
                ;;
        esac

        if command_exists apt-get; then printf "apt"; return; fi
        if command_exists dnf; then printf "dnf"; return; fi
        if command_exists pacman; then printf "pacman"; return; fi
        if command_exists zypper; then printf "zypper"; return; fi
        if command_exists emerge; then printf "emerge"; return; fi
        if command_exists snap; then printf "snap"; return; fi
        if command_exists flatpak; then printf "flatpak"; return; fi
        if command_exists bun; then printf "bun"; return; fi
        if command_exists npm; then printf "npm"; return; fi
    fi

    if command_exists brew; then printf "brew"; return; fi
    if command_exists winget; then printf "winget"; return; fi
    if command_exists choco; then printf "choco"; return; fi
    if command_exists scoop; then printf "scoop"; return; fi
    if command_exists bun; then printf "bun"; return; fi
    if command_exists npm; then printf "npm"; return; fi

    die "Unable to auto-detect a supported package manager. Use --manager."
}

detect_default_managers() {
    local emitted=""
    local primary_manager=""
    local manager
    local prefer_bun=0

    if manager_command_ready bun; then
        prefer_bun=1
    fi

    add_detected_manager() {
        local manager_name="$1"
        [[ -n "${manager_name}" ]] || return

        if [[ "${prefer_bun}" -eq 1 && "${manager_name}" == "npm" ]]; then
            return
        fi

        case " ${emitted} " in
            *" ${manager_name} "*)
                return
                ;;
        esac
        if manager_command_ready "${manager_name}"; then
            printf "%s\n" "${manager_name}"
            emitted+=" ${manager_name}"
        fi
    }

    primary_manager="$(detect_default_manager)"
    add_detected_manager "${primary_manager}"

    for manager in apt dnf pacman zypper emerge brew winget choco scoop snap flatpak bun npm; do
        add_detected_manager "${manager}"
    done

    if [[ -n "${emitted}" ]]; then
        return
    fi

    die "Unable to auto-detect supported package managers. Use --manager."
}

join_manager_labels() {
    local out=""
    local mgr

    for mgr in "$@"; do
        [[ -n "${mgr}" ]] || continue
        if [[ -n "${out}" ]]; then
            out+=", "
        fi
        out+="$(manager_label "${mgr}")"
    done

    printf "%s" "${out}"
}

join_manager_labels_with_ids() {
    local out=""
    local mgr

    for mgr in "$@"; do
        [[ -n "${mgr}" ]] || continue
        if [[ -n "${out}" ]]; then
            out+=", "
        fi
        out+="$(manager_label "${mgr}") (${mgr})"
    done

    printf "%s" "${out}"
}

build_help_file() {
    local default_managers="$1"

    cat >"${HELP_FILE}" <<EOF
${SCRIPT_NAME} - fuzzy package finder

Syntax:
  ${SCRIPT_NAME} [manager option] [action option] [query]
  ${SCRIPT_NAME} -m|--manager <name> [action option] [query]

Default behavior:
  Fuzzy-search available packages and install selected items.

Detected default manager(s):
  ${default_managers}

Action options:
  -l, --list-installed   Fuzzy-search installed packages and show details
  -R, --remove           Fuzzy-search installed packages and remove selected
  -U, --update           Run manager update/upgrade flow
  --refresh              Refresh manager package catalogs only
  -y, --yes              Assume yes for confirmation prompts
  -v, --version          Print version and exit
  -h, --help             Show this help

Manager options (one or two-letter style):
  -ap, --apt             Use APT
  -dn, --dnf             Use DNF
  -pm, --pacman          Use Pacman
  -zy, --zypper          Use Zypper
  -em, --emerge          Use Portage (emerge)
  -br, --brew            Use Homebrew
  -wg, --winget          Use WinGet
  -ch, --choco           Use Chocolatey
  -sc, --scoop           Use Scoop
  -sn, --snap            Use Snap
  -fp, --flatpak         Use Flatpak
  -np, --npm             Use npm (global packages)
  -bn, --bun             Use bun (global packages)
  -ad, --auto            Force auto-detection mode

Examples:
  ${SCRIPT_NAME} docker
  ${SCRIPT_NAME} -dn nginx
  ${SCRIPT_NAME} -ap -l openssl
  ${SCRIPT_NAME} -br -R wget
  ${SCRIPT_NAME} -sn firefox
  ${SCRIPT_NAME} -fp org.gimp.GIMP
  ${SCRIPT_NAME} -wg Microsoft.VisualStudioCode
  ${SCRIPT_NAME} -np eslint
  ${SCRIPT_NAME} -ch git
  ${SCRIPT_NAME} -m apt ripgrep

Supported managers:
  $(manager_list)
EOF
}

build_keybind_file() {
    cat >"${KBINDS_FILE}" <<'EOF'
Keybinds:

  ctrl-h  Show help in preview pane
  ctrl-k  Show keybinds in preview pane
  ctrl-/  Toggle preview pane
  ctrl-n  Move to next selected package
  ctrl-b  Move to previous selected package
EOF
}

print_help() {
    cat "${HELP_FILE}"
}

print_version() {
    printf "%s %s\n" "${SCRIPT_NAME}" "${SCRIPT_VERSION}"
}

parse_args() {
    local manager_value=""

    while (($#)); do
        case "$1" in
            -h|--help)
                ACTION="help"
                ;;
            -v|--version)
                ACTION="version"
                ;;
            -l|--list-installed)
                ACTION="list"
                ;;
            -R|--remove)
                ACTION="remove"
                ;;
            -U|--update)
                ACTION="update"
                ;;
            --refresh)
                ACTION="refresh"
                ;;
            -y|--yes)
                ASSUME_YES="1"
                ;;
            --feed-search)
                ACTION="feed-search"
                ;;
            --ipc-reload)
                ACTION="ipc-reload"
                ;;
            --ipc-query-notify)
                ACTION="ipc-query-notify"
                ;;
            --preview-item)
                ACTION="preview-item"
                ;;
            --bun-refresh-worker)
                ACTION="bun-refresh-worker"
                ;;
            -ap|--apt)
                MANAGER_OVERRIDE="apt"
                ;;
            -dn|--dnf)
                MANAGER_OVERRIDE="dnf"
                ;;
            -pm|--pacman)
                MANAGER_OVERRIDE="pacman"
                ;;
            -zy|--zypper)
                MANAGER_OVERRIDE="zypper"
                ;;
            -em|--emerge)
                MANAGER_OVERRIDE="emerge"
                ;;
            -br|--brew)
                MANAGER_OVERRIDE="brew"
                ;;
            -wg|--winget)
                MANAGER_OVERRIDE="winget"
                ;;
            -ch|--choco)
                MANAGER_OVERRIDE="choco"
                ;;
            -sc|--scoop)
                MANAGER_OVERRIDE="scoop"
                ;;
            -sn|--snap)
                MANAGER_OVERRIDE="snap"
                ;;
            -fp|--flatpak)
                MANAGER_OVERRIDE="flatpak"
                ;;
            -np|--npm)
                MANAGER_OVERRIDE="npm"
                ;;
            -bn|--bun)
                MANAGER_OVERRIDE="bun"
                ;;
            -ad|--auto)
                MANAGER_OVERRIDE=""
                ;;
            -m|--manager)
                shift
                [[ $# -gt 0 ]] || die "Missing value for --manager"
                manager_value="$(trim_whitespace "$1")"
                [[ -n "${manager_value}" ]] || die "Missing value for --manager"
                [[ "${manager_value}" != -* ]] || die "Missing value for --manager"
                MANAGER_OVERRIDE="$(normalize_manager "${manager_value}")"
                ;;
            -m=*|--manager=*)
                manager_value="$(trim_whitespace "${1#*=}")"
                [[ -n "${manager_value}" ]] || die "Missing value for --manager"
                [[ "${manager_value}" != -* ]] || die "Missing value for --manager"
                MANAGER_OVERRIDE="$(normalize_manager "${manager_value}")"
                ;;
            --)
                shift
                while (($#)); do
                    QUERY_PARTS+=("$1")
                    shift
                done
                break
                ;;
            -*)
                die "Invalid option: $1"
                ;;
            *)
                QUERY_PARTS+=("$1")
                ;;
        esac
        shift
    done
}

join_query() {
    local query=""
    local part

    if (( ${#QUERY_PARTS[@]} == 0 )); then
        printf ""
        return
    fi

    for part in "${QUERY_PARTS[@]-}"; do
        if [[ -z "${query}" ]]; then
            query="${part}"
        else
            query+=" ${part}"
        fi
    done
    printf "%s" "${query}"
}

dynamic_reload_enabled() {
    local manager_count="$1"
    local mode="${FPF_DYNAMIC_RELOAD:-always}"

    case "${mode}" in
        always|auto|on|1|true|yes)
            return 0
            ;;
        never|off|0|false|no)
            return 1
            ;;
        single)
            [[ "${manager_count}" -eq 1 ]]
            ;;
        *)
            return 0
            ;;
    esac
}

dynamic_reload_use_ipc() {
    local transport="${FPF_DYNAMIC_RELOAD_TRANSPORT:-reload}"

    case "${transport}" in
        ipc|listen|http)
            fzf_supports_listen
            ;;
        auto)
            fzf_supports_listen
            ;;
        *)
            return 1
            ;;
    esac
}

rank_display_rows_by_query() {
    local query="$1"
    local input_file="$2"
    local ranked_file
    local has_exact=0
    local candidate

    [[ -n "${query}" ]] || return 0

    while IFS= read -r candidate; do
        [[ -n "${candidate}" ]] || continue
        if awk -F'\t' -v cand="${candidate}" 'tolower($2) == tolower(cand) { found=1; exit } END { exit (found ? 0 : 1) }' "${input_file}"; then
            has_exact=1
            break
        fi
    done < <(exact_query_candidates "${query}" | awk '!seen[$0]++')

    ranked_file="$(mktemp "${SESSION_TMP_ROOT}/ranked.XXXXXX")"

    awk -F'\t' -v query="${query}" -v has_exact="${has_exact}" '
        function lower(s) { return tolower(s) }
        function normalize(s, t) {
            t = lower(s)
            gsub(/[^[:alnum:]]+/, "", t)
            return t
        }
        BEGIN {
            q = lower(query)
            gsub(/^[[:space:]]+|[[:space:]]+$/, "", q)
            q_norm = normalize(q)

            token_total = split(q, raw_tokens, /[^[:alnum:]]+/)
            query_token_count = 0
            for (i = 1; i <= token_total; i++) {
                if (raw_tokens[i] != "") {
                    query_tokens[++query_token_count] = raw_tokens[i]
                }
            }
        }
        {
            mgr = lower($1)
            pkg = $2
            desc = $3

            pkg_l = lower(pkg)
            desc_l = lower(desc)
            pkg_norm = normalize(pkg_l)
            desc_norm = normalize(desc_l)

            pkg_token_hits = 0
            desc_token_hits = 0
            for (i = 1; i <= query_token_count; i++) {
                token = query_tokens[i]
                if (index(pkg_l, token) > 0 || index(pkg_norm, token) > 0) {
                    pkg_token_hits++
                }
                if (index(desc_l, token) > 0 || index(desc_norm, token) > 0) {
                    desc_token_hits++
                }
            }

            pkg_token_count = 0
            split(pkg_l, pkg_parts, /[^[:alnum:]]+/)
            for (i in pkg_parts) {
                if (pkg_parts[i] != "") {
                    pkg_token_count++
                }
            }

            score = 12
            if (q != "") {
                if (pkg_l == q || (q_norm != "" && pkg_norm == q_norm)) {
                    score = 0
                } else if (q_norm != "" && index(pkg_norm, q_norm) == 1) {
                    score = 1
                } else if (query_token_count > 1 && pkg_token_hits == query_token_count) {
                    score = 2
                } else if (q_norm != "" && index(pkg_norm, q_norm) > 0) {
                    score = 3
                } else if (query_token_count > 0 && pkg_token_hits > 0) {
                    score = 4
                } else if (query_token_count > 0 && desc_token_hits == query_token_count) {
                    score = 5
                } else if (query_token_count > 0 && desc_token_hits > 0) {
                    score = 6
                }
            }

            if (q != "" && has_exact == 1 && pkg_token_hits == query_token_count && query_token_count > 0 && pkg_token_count > query_token_count) {
                score += 5
            }

            if (q != "" && desc_l ~ /(plugin|template|starter|boilerplate|router|hooks?|mcp|integration)/) {
                score += 2
            }

            mgr_bias = 0
            if (mgr == "npm") {
                mgr_bias = 4
            } else if (mgr == "bun") {
                mgr_bias = 3
            }

            print score "\t" mgr_bias "\t" (99 - pkg_token_hits) "\t" (99 - desc_token_hits) "\t" length(pkg) "\t" pkg_l "\t" $0
        }
    ' "${input_file}" |
        sort -t $'\t' -k1,1n -k2,2n -k3,3n -k4,4n -k5,5n -k6,6 |
        awk -F'\t' '{ print $7 "\t" $8 "\t" $9 }' >"${ranked_file}"

    mv "${ranked_file}" "${input_file}"
}

exact_query_candidates() {
    local query="$1"
    local compact_query=""
    local dashed_query=""
    local underscored_query=""
    local nospace_query=""

    compact_query="$(printf "%s" "${query}" | awk '{$1=$1; print}')"
    [[ -n "${compact_query}" ]] || return 0

    printf "%s\n" "${compact_query}"

    if [[ "${compact_query}" == *[[:space:]]* ]]; then
        dashed_query="${compact_query// /-}"
        underscored_query="${compact_query// /_}"
        nospace_query="${compact_query// /}"
        printf "%s\n" "${dashed_query}"
        printf "%s\n" "${underscored_query}"
        printf "%s\n" "${nospace_query}"
    fi
}

exact_match_entry() {
    local manager="$1"
    local query="$2"
    local candidate

    if [[ -z "${query}" ]]; then
        return 0
    fi

    while IFS= read -r candidate; do
        [[ -n "${candidate}" ]] || continue

        case "${manager}" in
            brew)
                if brew info --formula "${candidate}" >/dev/null 2>&1 || brew info --cask "${candidate}" >/dev/null 2>&1; then
                    printf "%s\t-\n" "${candidate}"
                    return 0
                fi
                ;;
            npm)
                if command_exists npm && npm view "${candidate}" name >/dev/null 2>&1; then
                    printf "%s\t-\n" "${candidate}"
                    return 0
                fi
                ;;
            bun)
                if bun info "${candidate}" >/dev/null 2>&1 || (command_exists npm && npm view "${candidate}" name >/dev/null 2>&1); then
                    printf "%s\t-\n" "${candidate}"
                    return 0
                fi
                ;;
        esac
    done < <(exact_query_candidates "${query}" | awk '!seen[$0]++')
}

manager_bun_search_entries_strict() {
    local query="$1"
    local effective_query="${query}"
    local line_limit=0
    local query_line_limit=40
    local effective_limit=0
    local bun_search_file

    if [[ -z "${query}" ]]; then
        line_limit="${FPF_NO_QUERY_RESULT_LIMIT:-120}"
    else
        query_line_limit="${FPF_QUERY_PER_MANAGER_LIMIT:-40}"
    fi

    if ! [[ "${line_limit}" =~ ^[0-9]+$ ]]; then
        line_limit=0
    fi

    if ! [[ "${query_line_limit}" =~ ^[0-9]+$ ]]; then
        query_line_limit=40
    fi

    if [[ "${line_limit}" -gt 0 ]]; then
        effective_limit="${line_limit}"
    else
        effective_limit="${query_line_limit}"
    fi

    if [[ -z "${effective_query}" ]]; then
        effective_query="aa"
    fi

    bun_search_file="$(mktemp "${SESSION_TMP_ROOT}/bun-search-strict.XXXXXX")"
    if ! bun search "${effective_query}" >"${bun_search_file}" 2>/dev/null; then
        rm -f "${bun_search_file}"
        return 1
    fi

    {
        awk 'NR > 1 && NF > 0 { name=$1; $1=""; sub(/^[[:space:]]+/, "", $0); if ($0 == "") $0="-"; print name "\t" $0 }' "${bun_search_file}"
        exact_match_entry "bun" "${query}"
    } | awk -F'\t' 'NF >= 1 { if ($2 == "") $2 = "-"; print $1 "\t" $2 }' | awk -F'\t' '!seen[$1]++' | {
        if [[ "${effective_limit}" -gt 0 ]]; then
            awk -v limit="${effective_limit}" 'NR <= limit'
        else
            cat
        fi
    }

    rm -f "${bun_search_file}"
}

manager_search_entries_uncached() {
    local manager="$1"
    local query="$2"
    local effective_query="${query}"
    local npm_search_limit=500
    local line_limit=0
    local query_line_limit=40
    local effective_limit=0

    if [[ -z "${query}" ]]; then
        npm_search_limit="${FPF_NO_QUERY_NPM_LIMIT:-120}"
        line_limit="${FPF_NO_QUERY_RESULT_LIMIT:-120}"
    else
        query_line_limit="${FPF_QUERY_PER_MANAGER_LIMIT:-40}"
    fi

    if ! [[ "${npm_search_limit}" =~ ^[0-9]+$ ]] || [[ "${npm_search_limit}" -eq 0 ]]; then
        npm_search_limit=500
    fi

    if ! [[ "${line_limit}" =~ ^[0-9]+$ ]]; then
        line_limit=0
    fi

    if ! [[ "${query_line_limit}" =~ ^[0-9]+$ ]]; then
        query_line_limit=40
    fi

    if [[ "${line_limit}" -gt 0 ]]; then
        effective_limit="${line_limit}"
    else
        effective_limit="${query_line_limit}"
    fi

    if [[ -z "${effective_query}" ]]; then
        case "${manager}" in
            apt|dnf|pacman|zypper|emerge|choco|scoop|snap)
                effective_query="a"
                ;;
            brew|npm|bun)
                effective_query="aa"
                ;;
            winget)
                effective_query="aa"
                ;;
        esac
    fi

    case "${manager}" in
        apt)
            if ensure_search_catalog_cache "${manager}"; then
                search_entries_from_catalog_cache "${manager}" "${effective_query}" || true
            else
                apt-cache search -- "${effective_query}" 2>/dev/null |
                    awk -F' - ' '{ name=$1; desc=$2; gsub(/^[[:space:]]+|[[:space:]]+$/, "", name); if (desc == "") desc="-"; print name "\t" desc }'
            fi
            ;;
        dnf)
            local pattern="*"
            if [[ -n "${effective_query}" ]]; then
                pattern="*${effective_query}*"
            fi
            dnf -q list available "${pattern}" 2>/dev/null |
                awk 'NR > 1 && $1 !~ /^(Available|Last|Installed)/ { name=$1; sub(/\.[^.]+$/, "", name); print name "\t" $2 }'
            ;;
        pacman)
            pacman -Ss -- "${effective_query}" 2>/dev/null |
                awk '
                    NR % 2 == 1 {
                        split($1, parts, "/")
                        pkg = parts[2]
                        next
                    }
                    NR % 2 == 0 {
                        line = $0
                        sub(/^[[:space:]]+/, "", line)
                        if (pkg != "") print pkg "\t" line
                    }
                '
            ;;
        zypper)
            zypper --non-interactive --quiet search --details --type package "${effective_query}" 2>/dev/null |
                awk -F'|' '
                    /^[[:space:]]*[ivp ][[:space:]]*\|/ {
                        name=$3
                        ver=$5
                        repo=$7
                        gsub(/^[[:space:]]+|[[:space:]]+$/, "", name)
                        gsub(/^[[:space:]]+|[[:space:]]+$/, "", ver)
                        gsub(/^[[:space:]]+|[[:space:]]+$/, "", repo)
                        if (name != "") print name "\tversion " ver " from " repo
                    }
                '
            ;;
        emerge)
            emerge --searchdesc --color=n "${effective_query}" 2>/dev/null |
                awk '
                    /^\*  / {
                        atom=$2
                        desc="-"
                        next
                    }
                    /^[[:space:]]+Description:/ {
                        line=$0
                        sub(/^[[:space:]]+Description:[[:space:]]*/, "", line)
                        desc=line
                        if (atom != "") print atom "\t" desc
                        atom=""
                    }
                '
            ;;
        brew)
            if ensure_search_catalog_cache "${manager}"; then
                {
                    search_entries_from_catalog_cache "${manager}" "${effective_query}" || true
                    exact_match_entry "${manager}" "${query}"
                }
            else
                {
                    brew search "${effective_query}" 2>/dev/null |
                        awk 'NF > 0 && $1 != "==>" { print $1 "\t-" }'
                    exact_match_entry "${manager}" "${query}"
                }
            fi
            ;;
        winget)
            winget search "${effective_query}" --source winget --accept-source-agreements --disable-interactivity 2>/dev/null |
                awk '
                    /^[[:space:]]*$/ { next }
                    /^Name[[:space:]]+Id[[:space:]]+/ { next }
                    /^[-[:space:]]+$/ { next }
                    {
                        line = $0
                        sub(/^[[:space:]]+/, "", line)
                        pkg = ""
                        n = split(line, cols, /[[:space:]][[:space:]]+/)
                        if (n >= 2) {
                            pkg = cols[2]
                        }
                        if (pkg != "") {
                            print pkg "\t-"
                        }
                    }
                '
            ;;
        choco)
            choco search "${effective_query}" --limit-output 2>/dev/null |
                awk -F'|' 'NF >= 1 && $1 != "" { ver=$2; if (ver == "") ver="-"; print $1 "\tversion " ver }'
            ;;
        scoop)
            scoop search "${effective_query}" 2>/dev/null |
                awk '
                    /^[[:space:]]*$/ { next }
                    /^[-[:space:]]+$/ { next }
                    /^Name[[:space:]]+/ { next }
                    {
                        name = $1
                        $1 = ""
                        sub(/^[[:space:]]+/, "", $0)
                        if ($0 == "") $0 = "-"
                        print name "\t" $0
                    }
                '
            ;;
        snap)
            snap find "${effective_query}" 2>/dev/null |
                awk '
                    NR == 1 { next }
                    NF > 0 {
                        name=$1
                        $1=""
                        sub(/^[[:space:]]+/, "", $0)
                        if ($0 == "") $0 = "-"
                        print name "\t" $0
                    }
                '
            ;;
        flatpak)
            ensure_flatpak_flathub_remote >/dev/null 2>&1 || true
            if [[ -z "${effective_query}" ]]; then
                {
                    flatpak remote-ls --app --columns=application,description flathub 2>/dev/null ||
                    flatpak remote-ls --app --columns=application,description 2>/dev/null
                } |
                    awk 'NR > 1 { name=$1; $1=""; sub(/^[[:space:]]+/, "", $0); if ($0 == "") $0="-"; print name "\t" $0 }'
            else
                {
                    flatpak search --columns=application,description "${effective_query}" 2>/dev/null ||
                    flatpak search "${effective_query}" 2>/dev/null
                } |
                    awk 'NR > 1 { name=$1; $1=""; sub(/^[[:space:]]+/, "", $0); if ($0 == "") $0="-"; print name "\t" $0 }'
            fi
            ;;
        npm)
            {
                npm search "${effective_query}" --searchlimit="${npm_search_limit}" --parseable 2>/dev/null |
                    awk -F'\t' 'NF >= 2 { print $1 "\t" $2 }'
                exact_match_entry "${manager}" "${query}"
            }
            ;;
        bun)
            {
                local bun_search_file
                bun_search_file="$(mktemp "${SESSION_TMP_ROOT}/bun-search.XXXXXX")"
                if bun search "${effective_query}" >"${bun_search_file}" 2>/dev/null; then
                    awk 'NR > 1 && NF > 0 { name=$1; $1=""; sub(/^[[:space:]]+/, "", $0); if ($0 == "") $0="-"; print name "\t" $0 }' "${bun_search_file}"
                elif command_exists npm; then
                    npm search "${effective_query}" --searchlimit="${npm_search_limit}" --parseable 2>/dev/null |
                        awk -F'\t' 'NF >= 2 { print $1 "\t" $2 }'
                fi
                rm -f "${bun_search_file}"
                exact_match_entry "${manager}" "${query}"
            } || true
            ;;
    esac | awk -F'\t' 'NF >= 1 { if ($2 == "") $2 = "-"; print $1 "\t" $2 }' | awk -F'\t' '!seen[$1]++' | {
        if [[ "${effective_limit}" -gt 0 ]]; then
            awk -v limit="${effective_limit}" 'NR <= limit'
        else
            cat
        fi
    } || true
}

manager_search_entries() {
    local manager="$1"
    local query="$2"
    local query_cache_enabled="${FPF_ENABLE_QUERY_CACHE:-0}"
    local bun_cache_ttl="${FPF_BUN_QUERY_CACHE_TTL:-900}"
    local bypass_query_cache="${FPF_BYPASS_QUERY_CACHE:-0}"
    local flags
    local key
    local fingerprint
    local cache_file
    local output_tmp
    local generation
    local should_async_refresh=0

    initialize_cache_root

    flags="$(query_cache_flags)"

    if ! [[ "${bun_cache_ttl}" =~ ^[0-9]+$ ]]; then
        bun_cache_ttl=900
    fi

    case "${bypass_query_cache}" in
        1|true|yes|on)
            query_cache_enabled="0"
            ;;
        *)
            if [[ "${manager}" == "bun" ]]; then
                query_cache_enabled="1"
            fi
            ;;
    esac

    key="$(cache_query_key "${manager}" "${query}" "${flags}")"
    fingerprint="$(cache_fingerprint "${manager}" "${query}" "${flags}")"
    cache_file="$(cache_path_for_key "${key}")"

    if [[ "${manager}" == "bun" && "${query_cache_enabled}" == "1" && ( "${ACTION}" == "feed-search" || "${ACTION}" == "ipc-query-notify" ) ]]; then
        if [[ -s "${cache_file}" ]]; then
            cache_emit_query_rows_if_valid "${cache_file}" || true
        fi

        if cache_is_fresh_with_ttl "${key}" "${bun_cache_ttl}"; then
            return
        fi

        generation="$(bun_generation_next "${key}")"
        if [[ -n "${FZF_PORT:-}" && "${FPF_BUN_SKIP_REFRESH_SCHEDULE:-0}" != "1" ]]; then
            should_async_refresh=1
        fi

        if [[ "${FPF_BUN_TEST_SYNC_REFRESH:-0}" == "1" ]]; then
            should_async_refresh=0
        fi

        if [[ "${should_async_refresh}" -eq 1 ]]; then
            start_bun_refresh_worker_async "${manager}" "${query}" "${flags}" "${key}" "${fingerprint}" "${generation}" "${FPF_IPC_FALLBACK_FILE:-}" "${FPF_IPC_MANAGER_OVERRIDE:-}"
            return
        fi

        bun_run_refresh_worker "${manager}" "${query}" "${flags}" "${key}" "${fingerprint}" "${generation}" || true
        if [[ -s "${cache_file}" ]]; then
            cache_emit_query_rows_if_valid "${cache_file}" || true
        fi
        return
    fi

    if [[ "${query_cache_enabled}" == "1" && -s "${cache_file}" ]]; then
        if [[ "${manager}" != "bun" ]] || cache_is_fresh_with_ttl "${key}" "${bun_cache_ttl}"; then
            cat "${cache_file}"
            return
        fi
    fi

    output_tmp="$(mktemp "${SESSION_TMP_ROOT}/query-cache.XXXXXX")"
    manager_search_entries_uncached "${manager}" "${query}" >"${output_tmp}" || true

    if [[ "${query_cache_enabled}" == "1" ]]; then
        cache_store_key_from_file "${key}" "${fingerprint}" "${output_tmp}"
    fi

    cat "${output_tmp}"
    rm -f "${output_tmp}"
}

manager_installed_entries() {
    local manager="$1"

    case "${manager}" in
        apt)
            dpkg-query -W -f='${binary:Package}\t${Version}\n' 2>/dev/null
            ;;
        dnf)
            dnf -q list installed 2>/dev/null |
                awk 'NR > 1 && $1 !~ /^(Installed|Last)/ { name=$1; sub(/\.[^.]+$/, "", name); print name "\t" $2 }'
            ;;
        pacman)
            pacman -Q 2>/dev/null |
                awk '{ print $1 "\t" $2 }'
            ;;
        zypper)
            zypper --non-interactive --quiet search --installed-only --details --type package 2>/dev/null |
                awk -F'|' '
                    /^[[:space:]]*i[[:space:]]*\|/ {
                        name=$3
                        ver=$5
                        gsub(/^[[:space:]]+|[[:space:]]+$/, "", name)
                        gsub(/^[[:space:]]+|[[:space:]]+$/, "", ver)
                        if (name != "") print name "\t" ver
                    }
                '
            ;;
        emerge)
            if command_exists qlist; then
                qlist -ICv 2>/dev/null |
                    awk '{ print $1 "\tinstalled" }'
            else
                local pkg_dir
                for pkg_dir in /var/db/pkg/*/*; do
                    [[ -d "${pkg_dir}" ]] || continue
                    printf "%s\tinstalled\n" "$(basename "${pkg_dir}")"
                done
            fi
            ;;
        brew)
            brew list --versions 2>/dev/null |
                awk '{ name=$1; $1=""; sub(/^[[:space:]]+/, "", $0); if ($0 == "") $0="installed"; print name "\t" $0 }'
            ;;
        winget)
            winget list --source winget --accept-source-agreements --disable-interactivity 2>/dev/null |
                awk '
                    /^[[:space:]]*$/ { next }
                    /^Name[[:space:]]+Id[[:space:]]+/ { next }
                    /^[-[:space:]]+$/ { next }
                    {
                        line = $0
                        sub(/^[[:space:]]+/, "", line)

                        pkg = ""
                        ver = "installed"

                        n = split(line, cols, /[[:space:]][[:space:]]+/)
                        if (n >= 2) {
                            pkg = cols[2]
                        }
                        if (n >= 3 && cols[3] != "") {
                            ver = cols[3]
                        }

                        if (pkg != "") {
                            print pkg "\t" ver
                        }
                    }
                '
            ;;
        choco)
            choco list --local-only --limit-output 2>/dev/null |
                awk -F'|' 'NF >= 1 && $1 != "" { ver=$2; if (ver == "") ver="installed"; print $1 "\t" ver }'
            ;;
        scoop)
            scoop list 2>/dev/null |
                awk '
                    /^[[:space:]]*$/ { next }
                    /^[-[:space:]]+$/ { next }
                    /^Name[[:space:]]+/ { next }
                    {
                        ver = $2
                        if (ver == "") ver = "installed"
                        print $1 "\t" ver
                    }
                '
            ;;
        snap)
            snap list 2>/dev/null |
                awk 'NR > 1 { print $1 "\t" $2 }'
            ;;
        flatpak)
            flatpak list --app --columns=application,version 2>/dev/null |
                awk 'NR > 1 { print $1 "\t" $2 }'
            ;;
        npm)
            npm ls -g --depth=0 --parseable 2>/dev/null |
                awk '
                    NR > 1 {
                        line = $0
                        gsub(/\r/, "", line)
                        gsub(/\\/, "/", line)

                        n = split(line, parts, "/")
                        if (n < 1) next

                        pkg = parts[n]
                        if (pkg == "" && n > 1) pkg = parts[n - 1]
                        if (pkg == "") next

                        if (n >= 2 && parts[n - 1] ~ /^@/) {
                            pkg = parts[n - 1] "/" pkg
                        }

                        print pkg "\tglobal"
                    }
                '
            ;;
        bun)
            {
                local bun_pm_file
                bun_pm_file="$(mktemp "${SESSION_TMP_ROOT}/bun-pm.XXXXXX")"
                if bun pm ls --global >"${bun_pm_file}" 2>/dev/null; then
                    awk '
                        NR > 1 {
                            line = $0
                            gsub(/\r/, "", line)
                            sub(/^[[:space:]]*[^[:alnum:]@]*/, "", line)
                            sub(/^[[:space:]]+/, "", line)
                            sub(/[[:space:]]+$/, "", line)

                            if (line == "") next
                            if (line ~ /[[:space:]]node_modules([[:space:]]|$)/) next

                            split(line, fields, /[[:space:]]+/)
                            pkg = fields[1]
                            if (pkg == "") next

                            pkg_copy = pkg
                            at_count = gsub(/@/, "@", pkg_copy)
                            if ((substr(pkg, 1, 1) == "@" && at_count >= 2) || (substr(pkg, 1, 1) != "@" && at_count >= 1)) {
                                sub(/@[^@[:space:]]*$/, "", pkg)
                            }

                            if (pkg != "") {
                                print pkg "\tglobal"
                            }
                        }
                    ' "${bun_pm_file}"
                elif command_exists npm; then
                    npm ls -g --depth=0 --parseable 2>/dev/null |
                        awk '
                            NR > 1 {
                                line = $0
                                gsub(/\r/, "", line)
                                gsub(/\\/, "/", line)

                                n = split(line, parts, "/")
                                if (n < 1) next

                                pkg = parts[n]
                                if (pkg == "" && n > 1) pkg = parts[n - 1]
                                if (pkg == "") next

                                if (n >= 2 && parts[n - 1] ~ /^@/) {
                                    pkg = parts[n - 1] "/" pkg
                                }

                                print pkg "\tglobal"
                            }
                        '
                fi
                rm -f "${bun_pm_file}"
            } || true
            ;;
    esac | sort -u || true
}

manager_installed_names() {
    local manager="$1"
    manager_installed_entries "${manager}" | awk -F'\t' 'NF > 0 { print $1 }'
}

installed_cache_ttl_seconds() {
    local ttl_seconds="${FPF_INSTALLED_CACHE_TTL:-300}"

    if ! [[ "${ttl_seconds}" =~ ^[0-9]+$ ]]; then
        ttl_seconds="300"
    fi

    printf "%s" "${ttl_seconds}"
}

installed_cache_fingerprint() {
    local manager="$1"
    local command_path=""
    local extra_token=""

    case "${manager}" in
        apt)
            command_path="$(command -v dpkg-query 2>/dev/null || printf "missing")"
            ;;
        dnf)
            command_path="$(command -v dnf 2>/dev/null || printf "missing")"
            ;;
        pacman)
            command_path="$(command -v pacman 2>/dev/null || printf "missing")"
            ;;
        zypper)
            command_path="$(command -v zypper 2>/dev/null || printf "missing")"
            ;;
        emerge)
            if command_exists qlist; then
                command_path="$(command -v qlist 2>/dev/null || printf "missing")"
                extra_token="|mode=qlist"
            else
                command_path="/var/db/pkg"
                extra_token="|mode=vardb"
            fi
            ;;
        brew)
            command_path="$(command -v brew 2>/dev/null || printf "missing")"
            ;;
        winget)
            command_path="$(command -v winget 2>/dev/null || printf "missing")"
            ;;
        choco)
            command_path="$(command -v choco 2>/dev/null || printf "missing")"
            ;;
        scoop)
            command_path="$(command -v scoop 2>/dev/null || printf "missing")"
            ;;
        snap)
            command_path="$(command -v snap 2>/dev/null || printf "missing")"
            ;;
        flatpak)
            command_path="$(command -v flatpak 2>/dev/null || printf "missing")"
            ;;
        npm)
            command_path="$(command -v npm 2>/dev/null || printf "missing")"
            ;;
        bun)
            command_path="$(command -v bun 2>/dev/null || printf "missing")"
            if command_exists npm; then
                extra_token="|npm=$(command -v npm 2>/dev/null || printf "missing")"
            fi
            ;;
        *)
            command_path="unknown"
            ;;
    esac

    printf "%s|cmd=%s%s" "$(cache_fingerprint "${manager}" "" "installed")" "${command_path}" "${extra_token}"
}

manager_installed_names_cached() {
    local manager="$1"
    local output_file="$2"
    local cache_enabled="${FPF_DISABLE_INSTALLED_CACHE:-0}"
    local cache_ttl_seconds
    local cache_key
    local cache_file
    local cache_fingerprint_value
    local cached_fingerprint=""

    initialize_cache_root

    cache_key="$(cache_catalog_key "${manager}")"
    cache_file="$(cache_path_for_key "${cache_key}")"
    cache_ttl_seconds="$(installed_cache_ttl_seconds)"
    cache_fingerprint_value="$(installed_cache_fingerprint "${manager}")"

    if [[ "${cache_enabled}" != "1" && -s "${cache_file}" ]]; then
        cached_fingerprint="$(cache_meta_value_for_key "${cache_key}" "fingerprint" 2>/dev/null || true)"
        if [[ "${cached_fingerprint}" == "${cache_fingerprint_value}" ]] && cache_is_fresh_with_ttl "${cache_key}" "${cache_ttl_seconds}"; then
            cp "${cache_file}" "${output_file}"
            return
        fi
    fi

    manager_installed_names "${manager}" >"${output_file}" 2>/dev/null || true

    if [[ "${cache_enabled}" != "1" && -s "${output_file}" ]]; then
        cache_store_key_from_file "${cache_key}" "${cache_fingerprint_value}" "${output_file}"
    fi
}

mark_installed_packages() {
    local source_file="$1"
    local output_file="$2"
    local installed_file
    local installed_map_file
    local manager

    if [[ "${FPF_SKIP_INSTALLED_MARKERS:-0}" == "1" ]]; then
        awk -F'\t' '
            {
                desc = $3
                if (desc == "") desc = "-"
                print $1 "\t" $2 "\t  " desc
            }
        ' "${source_file}" >"${output_file}"
        return
    fi

    installed_map_file="$(mktemp "${SESSION_TMP_ROOT}/installed-map.XXXXXX")"
    : >"${installed_map_file}"

    while IFS= read -r manager; do
        [[ -n "${manager}" ]] || continue
        installed_file="$(mktemp "${SESSION_TMP_ROOT}/installed.${manager}.XXXXXX")"
        manager_installed_names_cached "${manager}" "${installed_file}"
        if [[ -s "${installed_file}" ]]; then
            awk -F'\t' -v mgr="${manager}" 'NF > 0 && $1 != "" { print mgr "\t" $1 }' "${installed_file}" >>"${installed_map_file}"
        fi
        rm -f "${installed_file}"
    done < <(awk -F'\t' 'NF >= 1 && $1 != "" { print $1 }' "${source_file}" | awk '!seen[$0]++')

    awk -F'\t' '
        FILENAME == ARGV[1] {
            key = $1 "\t" $2
            if ($1 != "" && $2 != "") {
                installed[key] = 1
            }
            next
        }
        {
            key = $1 "\t" $2
            mark = (installed[key] ? "* " : "  ")
            desc = $3
            if (desc == "") desc = "-"
            print $1 "\t" $2 "\t" mark desc
        }
    ' "${installed_map_file}" "${source_file}" >"${output_file}"

    rm -f "${installed_map_file}"
}

merge_search_display_rows() {
    local source_file="$1"
    local output_file="$2"

    if [[ ! -s "${source_file}" ]]; then
        : >"${output_file}"
        return
    fi

    sort -t $'\t' -k1,1 -k2,2 -k3,3 "${source_file}" |
        awk -F'\t' '
            NF >= 2 {
                key = $1 "\t" $2
                if (seen[key]++) {
                    next
                }
                desc = $3
                if (desc == "") desc = "-"
                print $1 "\t" $2 "\t" desc
            }
        ' >"${output_file}"
}

collect_search_display_rows() {
    local query="$1"
    local output_file="$2"
    shift 2
    local managers=("$@")
    local query_limit="${FPF_QUERY_RESULT_LIMIT:-0}"

    : >"${output_file}"

    local part_files=()
    local gather_pids=()
    local manager
    local part_file
    local gather_pid
    local merged_source_file
    local merged_marked_file

    for manager in "${managers[@]-}"; do
        part_file="$(mktemp "${SESSION_TMP_ROOT}/part.XXXXXX")"
        part_files+=("${part_file}")

        (
            local_source_file="$(mktemp "${SESSION_TMP_ROOT}/source.XXXXXX")"
            manager_search_entries "${manager}" "${query}" >"${local_source_file}" || true
            if [[ -s "${local_source_file}" ]]; then
                awk -F'\t' -v mgr="${manager}" '
                    NF >= 1 {
                        desc = $2
                        if (desc == "") desc = "-"
                        print mgr "\t" $1 "\t" desc
                    }
                ' "${local_source_file}" >"${part_file}"
            fi
            rm -f "${local_source_file}"
        ) &
        gather_pids+=("$!")
    done

    for gather_pid in "${gather_pids[@]-}"; do
        wait "${gather_pid}" || true
    done

    merged_source_file="$(mktemp "${SESSION_TMP_ROOT}/merged-source.XXXXXX")"
    merged_marked_file="$(mktemp "${SESSION_TMP_ROOT}/merged-marked.XXXXXX")"

    for part_file in "${part_files[@]-}"; do
        if [[ -s "${part_file}" ]]; then
            cat "${part_file}" >>"${merged_source_file}"
        fi
        rm -f "${part_file}"
    done

    if [[ -s "${merged_source_file}" ]]; then
        merge_search_display_rows "${merged_source_file}" "${merged_marked_file}"
        mark_installed_packages "${merged_marked_file}" "${output_file}"
        rank_display_rows_by_query "${query}" "${output_file}"

        if [[ -n "${query}" && "${query_limit}" =~ ^[0-9]+$ && "${query_limit}" -gt 0 ]]; then
            awk -v limit="${query_limit}" 'NR <= limit' "${output_file}" >"${output_file}.limited"
            mv "${output_file}.limited" "${output_file}"
        fi
    fi

    rm -f "${merged_source_file}" "${merged_marked_file}"
}

collect_installed_display_rows() {
    local output_file="$1"
    shift
    local managers=("$@")
    local part_files=()
    local gather_pids=()
    local manager
    local part_file
    local gather_pid

    : >"${output_file}"

    for manager in "${managers[@]-}"; do
        part_file="$(mktemp "${SESSION_TMP_ROOT}/part.XXXXXX")"
        part_files+=("${part_file}")

        (
            local local_source_file
            local_source_file="$(mktemp "${SESSION_TMP_ROOT}/source.XXXXXX")"
            manager_installed_entries "${manager}" >"${local_source_file}" || true
            if [[ -s "${local_source_file}" ]]; then
                awk -F'\t' -v mgr="${manager}" '
                    NF >= 1 {
                        desc = $2
                        if (desc == "") desc = "-"
                        print mgr "\t" $1 "\t" desc
                    }
                ' "${local_source_file}" >"${part_file}"
            fi
            rm -f "${local_source_file}"
        ) &
        gather_pids+=("$!")
    done

    for gather_pid in "${gather_pids[@]-}"; do
        wait "${gather_pid}" || true
    done

    for part_file in "${part_files[@]-}"; do
        if [[ -s "${part_file}" ]]; then
            cat "${part_file}" >>"${output_file}"
        fi
        rm -f "${part_file}"
    done

    if [[ -s "${output_file}" ]]; then
        sort -u "${output_file}" -o "${output_file}"
    fi
}

build_dynamic_reload_command() {
    local manager_override="$1"
    local fallback_file="$2"
    local script_path="${BASH_SOURCE[0]}"
    local min_chars="${FPF_RELOAD_MIN_CHARS:-2}"
    local reload_debounce="${FPF_RELOAD_DEBOUNCE:-0.12}"

    if ! [[ "${min_chars}" =~ ^[0-9]+$ ]]; then
        min_chars=2
    fi

    if ! [[ "${reload_debounce}" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
        reload_debounce=0.12
    fi

    if [[ "${script_path}" != /* ]]; then
        script_path="$(pwd)/${script_path}"
    fi

    if [[ -n "${manager_override}" ]]; then
        printf 'q={q}; if [ ${#q} -lt %s ]; then cat %q; else sleep %s; FPF_SKIP_INSTALLED_MARKERS=1 FPF_BYPASS_QUERY_CACHE=1 FPF_IPC_MANAGER_OVERRIDE=%q FPF_IPC_FALLBACK_FILE=%q %q --feed-search --manager %q -- "$q" 2>/dev/null || cat %q; fi' "${min_chars}" "${fallback_file}" "${reload_debounce}" "${manager_override}" "${fallback_file}" "${script_path}" "${manager_override}" "${fallback_file}"
    else
        printf 'q={q}; if [ ${#q} -lt %s ]; then cat %q; else sleep %s; FPF_SKIP_INSTALLED_MARKERS=1 FPF_BYPASS_QUERY_CACHE=1 FPF_IPC_MANAGER_OVERRIDE= FPF_IPC_FALLBACK_FILE=%q %q --feed-search -- "$q" 2>/dev/null || cat %q; fi' "${min_chars}" "${fallback_file}" "${reload_debounce}" "${fallback_file}" "${script_path}" "${fallback_file}"
    fi
}

build_dynamic_reload_command_for_query() {
    local manager_override="$1"
    local fallback_file="$2"
    local query_value="$3"
    local script_path="${BASH_SOURCE[0]}"
    local min_chars="${FPF_RELOAD_MIN_CHARS:-2}"
    local reload_debounce="${FPF_RELOAD_DEBOUNCE:-0.12}"

    if ! [[ "${min_chars}" =~ ^[0-9]+$ ]]; then
        min_chars=2
    fi

    if ! [[ "${reload_debounce}" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
        reload_debounce=0.12
    fi

    if [[ "${script_path}" != /* ]]; then
        script_path="$(pwd)/${script_path}"
    fi

    if [[ ${#query_value} -lt ${min_chars} ]]; then
        printf 'cat %q' "${fallback_file}"
        return
    fi

    if [[ -n "${manager_override}" ]]; then
        printf 'sleep %s; FPF_SKIP_INSTALLED_MARKERS=1 FPF_BYPASS_QUERY_CACHE=1 FPF_IPC_MANAGER_OVERRIDE=%q FPF_IPC_FALLBACK_FILE=%q %q --feed-search --manager %q -- %q 2>/dev/null || cat %q' "${reload_debounce}" "${manager_override}" "${fallback_file}" "${script_path}" "${manager_override}" "${query_value}" "${fallback_file}"
    else
        printf 'sleep %s; FPF_SKIP_INSTALLED_MARKERS=1 FPF_BYPASS_QUERY_CACHE=1 FPF_IPC_MANAGER_OVERRIDE= FPF_IPC_FALLBACK_FILE=%q %q --feed-search -- %q 2>/dev/null || cat %q' "${reload_debounce}" "${fallback_file}" "${script_path}" "${query_value}" "${fallback_file}"
    fi
}

build_dynamic_reload_ipc_command() {
    local manager_override="$1"
    local fallback_file="$2"
    local script_path="${BASH_SOURCE[0]}"

    if [[ "${script_path}" != /* ]]; then
        script_path="$(pwd)/${script_path}"
    fi

    printf 'FPF_IPC_MANAGER_OVERRIDE=%q FPF_IPC_FALLBACK_FILE=%q %q --ipc-reload -- "{q}"' "${manager_override}" "${fallback_file}" "${script_path}"
}

build_dynamic_query_notify_ipc_command() {
    local manager_override="$1"
    local fallback_file="$2"
    local script_path="${BASH_SOURCE[0]}"

    if [[ "${script_path}" != /* ]]; then
        script_path="$(pwd)/${script_path}"
    fi

    printf 'FPF_IPC_MANAGER_OVERRIDE=%q FPF_IPC_FALLBACK_FILE=%q %q --ipc-query-notify -- "{q}"' "${manager_override}" "${fallback_file}" "${script_path}"
}

fzf_supports_listen() {
    local fzf_help
    fzf_help="$(fzf --help 2>&1 || true)"
    [[ "${fzf_help}" == *"--listen"* ]]
}

fzf_supports_result_bind() {
    if [[ -n "${FPF_FZF_RESULT_BIND_SUPPORTED_CACHE:-}" ]]; then
        [[ "${FPF_FZF_RESULT_BIND_SUPPORTED_CACHE}" == "1" ]]
        return
    fi

    local probe_output=""
    probe_output="$(printf 'probe\n' | fzf --bind='result:abort' --filter probe 2>&1 >/dev/null || true)"

    if [[ "${probe_output}" == *"unsupported key: result"* ]]; then
        FPF_FZF_RESULT_BIND_SUPPORTED_CACHE="0"
        return 1
    fi

    FPF_FZF_RESULT_BIND_SUPPORTED_CACHE="1"
    return 0
}

send_fzf_listen_action() {
    local action_payload="$1"
    local listen_target="${FZF_PORT:-}"
    local host="127.0.0.1"
    local port=""
    local payload_size

    if [[ "${listen_target}" =~ ^[0-9]+$ ]]; then
        port="${listen_target}"
    elif [[ "${listen_target}" =~ ^([^:]+):([0-9]+)$ ]]; then
        host="${BASH_REMATCH[1]}"
        port="${BASH_REMATCH[2]}"
    elif [[ "${listen_target}" =~ ^https?://([^:/]+):([0-9]+)$ ]]; then
        host="${BASH_REMATCH[1]}"
        port="${BASH_REMATCH[2]}"
    elif [[ "${listen_target}" =~ ^\[([^]]+)\]:([0-9]+)$ ]]; then
        host="${BASH_REMATCH[1]}"
        port="${BASH_REMATCH[2]}"
    fi

    if [[ -z "${port}" ]] || ! [[ "${port}" =~ ^[0-9]+$ ]] || [[ "${port}" -le 0 || "${port}" -gt 65535 ]]; then
        return 1
    fi

    if [[ "${host}" == "0.0.0.0" || "${host}" == "*" ]]; then
        host="127.0.0.1"
    fi

    payload_size="$(printf "%s" "${action_payload}" | wc -c | tr -d '[:space:]')"

    if command_exists curl; then
        if curl --silent --show-error --fail --max-time 2 \
            --request POST \
            --header 'Content-Type: text/plain' \
            --data-binary "${action_payload}" \
            "http://${host}:${port}" >/dev/null 2>&1; then
            return 0
        fi
    fi

    if command_exists nc; then
        if {
            printf 'POST / HTTP/1.1\r\n'
            printf 'Host: %s:%s\r\n' "${host}" "${port}"
            printf 'Content-Type: text/plain\r\n'
            printf 'Content-Length: %s\r\n' "${payload_size}"
            printf '\r\n'
            printf '%s' "${action_payload}"
        } | nc -w 2 "${host}" "${port}" >/dev/null 2>&1; then
            return 0
        fi
    fi

    if exec 9<>"/dev/tcp/${host}/${port}" 2>/dev/null; then
        printf 'POST / HTTP/1.1\r\n' >&9
        printf 'Host: %s:%s\r\n' "${host}" "${port}" >&9
        printf 'Content-Type: text/plain\r\n' >&9
        printf 'Content-Length: %s\r\n' "${payload_size}" >&9
        printf '\r\n' >&9
        printf '%s' "${action_payload}" >&9
        exec 9>&-
        return 0
    fi

    return 1
}

send_fzf_prompt_action() {
    local prompt_text="$1"
    local action_payload

    action_payload="change-prompt(${prompt_text})"
    send_fzf_listen_action "${action_payload}"
}

run_ipc_reload_action() {
    local query="$1"
    local manager_override="${FPF_IPC_MANAGER_OVERRIDE:-}"
    local fallback_file="${FPF_IPC_FALLBACK_FILE:-}"
    local reload_command
    local action_payload

    if [[ -z "${fallback_file}" || ! -r "${fallback_file}" ]]; then
        return 1
    fi

    if [[ -n "${manager_override}" ]]; then
        manager_override="$(normalize_manager "${manager_override}")"
        manager_supported "${manager_override}" || return 1
    fi

    reload_command="$(build_dynamic_reload_command_for_query "${manager_override}" "${fallback_file}" "${query}")"
    action_payload="change-prompt(Search> )+reload(${reload_command})"
    send_fzf_listen_action "${action_payload}"
}

run_ipc_query_notify_action() {
    local query="$1"
    local manager_override="${FPF_IPC_MANAGER_OVERRIDE:-}"
    local fallback_file="${FPF_IPC_FALLBACK_FILE:-}"
    local min_chars="${FPF_RELOAD_MIN_CHARS:-2}"
    local target_manager=""
    local should_warm_bun=0

    if ! [[ "${min_chars}" =~ ^[0-9]+$ ]]; then
        min_chars=2
    fi

    if [[ ${#query} -lt ${min_chars} ]]; then
        run_ipc_reload_action "${query}" || send_fzf_prompt_action "Search> " || true
        return 0
    fi

    if [[ -z "${fallback_file}" || ! -r "${fallback_file}" ]]; then
        return 1
    fi

    if [[ -n "${manager_override}" ]]; then
        manager_override="$(normalize_manager "${manager_override}")"
        manager_supported "${manager_override}" || return 1
        target_manager="${manager_override}"
    else
        target_manager="bun"
    fi

    if [[ "${target_manager}" == "bun" ]] && manager_command_ready bun && [[ -n "${FZF_PORT:-}" ]]; then
        should_warm_bun=1
    fi

    send_fzf_prompt_action "Loading> " || true

    if [[ "${should_warm_bun}" -eq 1 ]]; then
        (
            FPF_IPC_MANAGER_OVERRIDE="${manager_override}" \
                FPF_IPC_FALLBACK_FILE="${fallback_file}" \
                manager_search_entries "bun" "${query}" >/dev/null 2>&1 || true
        ) &
    fi

    run_ipc_reload_action "${query}" || send_fzf_prompt_action "Search> " || true
}

manager_dispatch_action() {
    local manager="$1"
    local action="$2"
    shift 2 || true
    manager_execute_action "${manager}" "${action}" "$@"
}

manager_install() {
    local manager="$1"
    shift
    manager_dispatch_action "${manager}" "install" "$@"
}

manager_remove() {
    local manager="$1"
    shift
    manager_execute_action "${manager}" "remove" "$@"
}

manager_show_info() {
    local manager="$1"
    local package="$2"
    manager_execute_action "${manager}" "show_info" "${package}"
}

manager_update() {
    local manager="$1"
    manager_execute_action "${manager}" "update"
}

manager_refresh() {
    local manager="$1"
    manager_execute_action "${manager}" "refresh"
}

confirm_action() {
    local prompt="$1"
    local reply=""
    local normalized_reply=""

    if assume_yes_enabled; then
        return 0
    fi

    printf "%s [y/N]: " "${prompt}" >&2
    read -r reply || true
    reply="$(trim_whitespace "${reply}")"
    normalized_reply="$(printf "%s" "${reply}" | tr '[:upper:]' '[:lower:]')"

    case "${normalized_reply}" in
        y|yes)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

run_fuzzy_selector() {
    local query="$1"
    local input_file="$2"
    local header_line="$3"
    local reload_cmd="${4:-}"
    local reload_ipc_cmd="${5:-}"
    local script_path="${BASH_SOURCE[0]}"
    local quoted_script_path=""
    local quoted_help_file=""
    local quoted_kbinds_file=""
    local preview_cmd
    local fzf_shell

    if [[ "${script_path}" != /* ]]; then
        script_path="$(pwd)/${script_path}"
    fi

    printf -v quoted_script_path "%q" "${script_path}"
    printf -v quoted_help_file "%q" "${HELP_FILE}"
    printf -v quoted_kbinds_file "%q" "${KBINDS_FILE}"

    preview_cmd="FPF_SESSION_TMP_ROOT=$(printf '%q' "${SESSION_TMP_ROOT}") ${quoted_script_path} --preview-item --manager {1} -- {2}"
    if command_exists bash; then
        fzf_shell="bash"
    else
        fzf_shell=""
    fi

    local -a fzf_args=()
    fzf_args=(-q "${query}" -m \
        -e \
        --delimiter=$'\t' \
        --with-nth=1,2,3 \
        --preview="${preview_cmd}" \
        --preview-window=55%:wrap:border-sharp \
        --layout=reverse \
        --marker='>>' \
        --prompt='Search> ' \
        --header="${header_line}" \
        --info=inline \
        --margin="2%,1%,2%,1%" \
        --cycle \
        --tiebreak=begin,chunk,length \
        --bind="ctrl-k:preview:cat ${quoted_kbinds_file}" \
        --bind="ctrl-h:preview:cat ${quoted_help_file}" \
        --bind='ctrl-/:change-preview-window(hidden|)' \
        --bind=ctrl-n:next-selected,ctrl-b:prev-selected \
        --bind='focus:transform-preview-label:echo [{1}] {2}')

    if [[ -n "${reload_ipc_cmd}" ]]; then
        fzf_args+=(--listen=0)
        fzf_args+=(--bind="change:execute-silent:${reload_ipc_cmd}")
        if [[ -n "${reload_cmd}" ]]; then
            if fzf_supports_result_bind; then
                fzf_args+=(--bind="ctrl-r:change-prompt(Loading> )+reload:${reload_cmd}")
                fzf_args+=(--bind="result:change-prompt(Search> )")
            else
                fzf_args+=(--bind="ctrl-r:reload:${reload_cmd}")
            fi
        fi
    elif [[ -n "${reload_cmd}" ]]; then
        if fzf_supports_result_bind; then
            fzf_args+=(--bind="change:change-prompt(Loading> )+reload:${reload_cmd}")
            fzf_args+=(--bind="ctrl-r:change-prompt(Loading> )+reload:${reload_cmd}")
            fzf_args+=(--bind="result:change-prompt(Search> )")
        else
            fzf_args+=(--bind="change:reload:${reload_cmd}")
            fzf_args+=(--bind="ctrl-r:reload:${reload_cmd}")
        fi
    fi

    if [[ -n "${fzf_shell}" ]]; then
        SHELL="${fzf_shell}" fzf "${fzf_args[@]}" <"${input_file}"
    else
        fzf "${fzf_args[@]}" <"${input_file}"
    fi
}

main() {
    ensure_tmp_root
    initialize_session_tmp_root
    load_fpf_libraries
    if [[ -z "${FPF_SESSION_TMP_ROOT:-}" ]]; then
        trap cleanup_session_tmp_root EXIT
    fi

    parse_args "$@"

    if [[ "${ACTION}" == "ipc-reload" ]]; then
        run_ipc_reload_action "$(join_query)" || true
        exit 0
    fi

    if [[ "${ACTION}" == "ipc-query-notify" ]]; then
        run_ipc_query_notify_action "$(join_query)" || true
        exit 0
    fi

    if [[ "${ACTION}" == "preview-item" ]]; then
        local preview_manager="${MANAGER_OVERRIDE:-}"
        local preview_package

        preview_package="$(join_query)"
        run_preview_item_action "${preview_manager}" "${preview_package}" || true
        exit 0
    fi

    if [[ "${ACTION}" == "bun-refresh-worker" ]]; then
        local worker_manager="${MANAGER_OVERRIDE:-bun}"
        local worker_query
        local worker_flags
        local worker_key
        local worker_fingerprint
        local worker_generation

        worker_query="$(join_query)"
        worker_flags="${FPF_BUN_REFRESH_FLAGS:-$(query_cache_flags)}"
        worker_key="${FPF_BUN_REFRESH_KEY:-$(cache_query_key "${worker_manager}" "${worker_query}" "${worker_flags}")}"
        worker_fingerprint="${FPF_BUN_REFRESH_FINGERPRINT:-$(cache_fingerprint "${worker_manager}" "${worker_query}" "${worker_flags}")}"
        worker_generation="${FPF_BUN_REFRESH_GENERATION:-0}"

        if ! [[ "${worker_generation}" =~ ^[0-9]+$ ]] || [[ "${worker_generation}" -le 0 ]]; then
            exit 0
        fi

        initialize_cache_root
        bun_run_refresh_worker "${worker_manager}" "${worker_query}" "${worker_flags}" "${worker_key}" "${worker_fingerprint}" "${worker_generation}" || true
        exit 0
    fi

    if [[ "${ACTION}" == "version" ]]; then
        print_version
        exit 0
    fi

    local detected_manager
    local detected_managers=()
    while IFS= read -r detected_manager; do
        [[ -n "${detected_manager}" ]] || continue
        detected_managers+=("${detected_manager}")
    done < <(detect_default_managers)

    local default_managers_display
    default_managers_display="$(join_manager_labels_with_ids "${detected_managers[@]-}")"
    [[ -n "${default_managers_display}" ]] || default_managers_display="None"

    build_help_file "${default_managers_display}"
    build_keybind_file

    if [[ "${ACTION}" == "help" ]]; then
        print_help
        exit 0
    fi

    local managers=()
    if [[ -n "${MANAGER_OVERRIDE}" ]]; then
        managers+=("$(normalize_manager "${MANAGER_OVERRIDE}")")
    else
        for detected_manager in "${detected_managers[@]-}"; do
            [[ -n "${detected_manager}" ]] || continue
            managers+=("${detected_manager}")
        done
    fi

    if [[ "${#managers[@]}" -eq 0 ]]; then
        die "Unable to auto-detect supported package managers. Use --manager."
    fi

    local manager
    for manager in "${managers[@]-}"; do
        manager_supported "${manager}" || die "Unsupported manager: ${manager}"
        manager_command_ready "${manager}" || die "Manager command(s) for '${manager}' not found on this system"
    done

    local manager_display
    manager_display="$(join_manager_labels "${managers[@]-}")"

    local query
    query="$(join_query)"

    if [[ "${ACTION}" != "feed-search" ]]; then
        log "Using manager(s): ${manager_display}"
    fi

    if [[ "${ACTION}" == "update" ]]; then
        if confirm_action "Run update/upgrade for ${manager_display}?"; then
            for manager in "${managers[@]-}"; do
                log "Updating with $(manager_label "${manager}")"
                manager_update "${manager}"
            done
        else
            log "Update canceled"
        fi
        exit 0
    fi

    if [[ "${ACTION}" == "refresh" ]]; then
        if confirm_action "Refresh package catalogs for ${manager_display}?"; then
            for manager in "${managers[@]-}"; do
                log "Refreshing catalogs with $(manager_label "${manager}")"
                manager_refresh "${manager}"
            done
        else
            log "Refresh canceled"
        fi
        exit 0
    fi

    local display_file
    display_file="$(mktemp "${SESSION_TMP_ROOT}/display.XXXXXX")"
    : >"${display_file}"

    if [[ "${ACTION}" == "feed-search" ]]; then
        collect_search_display_rows "${query}" "${display_file}" "${managers[@]-}"
        if [[ -s "${display_file}" ]]; then
            cat "${display_file}"
        fi
        rm -f "${display_file}"
        exit 0
    fi

    ensure_fzf "${managers[@]-}"

    if [[ "${ACTION}" == "search" ]]; then
        run_with_loading_indicator "Loading packages from ${manager_display}" collect_search_display_rows "${query}" "${display_file}" "${managers[@]-}"
    else
        run_with_loading_indicator "Loading installed packages from ${manager_display}" collect_installed_display_rows "${display_file}" "${managers[@]-}"
    fi

    if [[ ! -s "${display_file}" ]]; then
        rm -f "${display_file}"

        if [[ "${ACTION}" == "search" && -z "${query}" && "${#managers[@]}" -eq 1 ]]; then
            local setup_message=""
            setup_message="$(manager_no_query_setup_message "${managers[0]}" || true)"
            if [[ -n "${setup_message}" ]]; then
                die "${setup_message}"
            fi
        fi

        if [[ -n "${query}" ]]; then
            die "No packages found for ${manager_display} matching '${query}'. Try a broader query or --manager."
        fi
        die "No packages found for ${manager_display}. Try adding a query or using --manager."
    fi

    local header
    case "${ACTION}" in
        search)
            header="Select package(s) to install with ${manager_display} (TAB to multi-select, * = installed)"
            ;;
        list)
            header="Select installed package(s) to inspect from ${manager_display}"
            ;;
        remove)
            header="Select installed package(s) to remove from ${manager_display}"
            ;;
        *)
            header="Select package(s)"
            ;;
    esac

    local reload_cmd=""
    local reload_ipc_cmd=""
    local reload_fallback_file="${display_file}"
    if [[ "${ACTION}" == "search" ]]; then
        if dynamic_reload_enabled "${#managers[@]}"; then
            if [[ -n "${query}" ]]; then
                reload_fallback_file="$(mktemp "${SESSION_TMP_ROOT}/reload-fallback.XXXXXX")"
                run_with_loading_indicator "Preparing baseline search results" collect_search_display_rows "" "${reload_fallback_file}" "${managers[@]-}"
                if [[ ! -s "${reload_fallback_file}" ]]; then
                    cp "${display_file}" "${reload_fallback_file}"
                fi
            fi

            reload_cmd="$(build_dynamic_reload_command "${MANAGER_OVERRIDE}" "${reload_fallback_file}")"
            if dynamic_reload_use_ipc; then
                reload_ipc_cmd="$(build_dynamic_query_notify_ipc_command "${MANAGER_OVERRIDE}" "${reload_fallback_file}")"
            fi
        fi
    fi

    local selected
    selected="$(run_fuzzy_selector "${query}" "${display_file}" "${header}" "${reload_cmd}" "${reload_ipc_cmd}" || true)"

    rm -f "${display_file}"
    if [[ "${reload_fallback_file}" != "${display_file}" ]]; then
        rm -f "${reload_fallback_file}"
    fi

    if [[ -z "${selected}" ]]; then
        log "Selection canceled"
        exit 0
    fi

    local selected_managers=()
    local selected_packages=()
    local selected_line
    local selected_line_number=0
    local selected_parse_failures=0
    local selected_manager
    local selected_pkg
    local normalized_selected_manager
    while IFS= read -r selected_line; do
        selected_line_number=$((selected_line_number + 1))
        [[ -n "${selected_line}" ]] || continue
        IFS=$'\t' read -r selected_manager selected_pkg _ <<<"${selected_line}"
        selected_manager="$(trim_whitespace "${selected_manager}")"
        selected_pkg="$(trim_whitespace "${selected_pkg}")"

        if [[ -z "${selected_manager}" || -z "${selected_pkg}" ]]; then
            selected_parse_failures=$((selected_parse_failures + 1))
            log_selection_parse_skip "${selected_line_number}" "missing manager/package fields" "${selected_line}"
            continue
        fi

        normalized_selected_manager="$(normalize_manager "${selected_manager}")"
        if ! manager_supported "${normalized_selected_manager}"; then
            selected_parse_failures=$((selected_parse_failures + 1))
            log_selection_parse_skip "${selected_line_number}" "unsupported manager '${normalized_selected_manager}'" "${selected_line}"
            continue
        fi

        selected_managers+=("${normalized_selected_manager}")
        selected_packages+=("${selected_pkg}")
    done <<<"${selected}"

    if [[ "${#selected_packages[@]}" -eq 0 ]]; then
        if [[ "${selected_parse_failures}" -gt 0 ]] && selection_debug_enabled; then
            log "Debug(selection): no executable entries after parsing ${selected_parse_failures} selected line(s)"
        fi
        log "Selection canceled"
        exit 0
    fi

    local unique_managers=()
    local candidate_manager
    local already_seen
    local existing_manager
    for candidate_manager in "${selected_managers[@]-}"; do
        already_seen=0
        for existing_manager in "${unique_managers[@]-}"; do
            if [[ "${existing_manager}" == "${candidate_manager}" ]]; then
                already_seen=1
                break
            fi
        done
        if [[ "${already_seen}" -eq 0 ]]; then
            unique_managers+=("${candidate_manager}")
        fi
    done

    local selected_manager_display
    selected_manager_display="$(join_manager_labels "${unique_managers[@]-}")"

    local idx
    local mgr_packages=()

    case "${ACTION}" in
        search)
            if confirm_action "Install ${#selected_packages[@]} package(s) with ${selected_manager_display}?"; then
                for manager in "${unique_managers[@]-}"; do
                    mgr_packages=()
                    for idx in "${!selected_packages[@]}"; do
                        if [[ "${selected_managers[$idx]}" == "${manager}" ]]; then
                            mgr_packages+=("${selected_packages[$idx]}")
                        fi
                    done
                    if [[ "${#mgr_packages[@]}" -gt 0 ]]; then
                        log "Installing ${#mgr_packages[@]} package(s) with $(manager_label "${manager}")"
                        manager_install "${manager}" "${mgr_packages[@]-}"
                    fi
                done
            else
                log "Install canceled"
            fi
            ;;
        remove)
            if confirm_action "Remove ${#selected_packages[@]} package(s) with ${selected_manager_display}?"; then
                for manager in "${unique_managers[@]-}"; do
                    mgr_packages=()
                    for idx in "${!selected_packages[@]}"; do
                        if [[ "${selected_managers[$idx]}" == "${manager}" ]]; then
                            mgr_packages+=("${selected_packages[$idx]}")
                        fi
                    done
                    if [[ "${#mgr_packages[@]}" -gt 0 ]]; then
                        log "Removing ${#mgr_packages[@]} package(s) with $(manager_label "${manager}")"
                        manager_remove "${manager}" "${mgr_packages[@]-}"
                    fi
                done
            else
                log "Remove canceled"
            fi
            ;;
        list)
            for idx in "${!selected_packages[@]}"; do
                printf "\n=== %s (%s) ===\n" "${selected_packages[$idx]}" "$(manager_label "${selected_managers[$idx]}")"
                manager_show_info "${selected_managers[$idx]}" "${selected_packages[$idx]}" || true
            done
            ;;
    esac
}

main "$@"
